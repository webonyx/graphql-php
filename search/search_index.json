{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"graphql-php","text":""},{"location":"#about-graphql","title":"About GraphQL","text":"<p>GraphQL is a modern way to build HTTP APIs consumed by the web and mobile clients. It is intended to be an alternative to REST and SOAP APIs (even for existing applications).</p> <p>GraphQL itself is a specification designed by Facebook engineers. Various implementations of this specification were written in different languages and environments.</p> <p>Great overview of GraphQL features and benefits is presented on the official website. All of them equally apply to this PHP implementation.</p>"},{"location":"#about-graphql-php","title":"About graphql-php","text":"<p>graphql-php is a feature-complete implementation of GraphQL specification in PHP. It was originally inspired by reference JavaScript implementation published by Facebook.</p> <p>This library is a thin wrapper around your existing data layer and business logic. It doesn't dictate how these layers are implemented or which storage engines are used. Instead, it provides tools for creating rich API for your existing app.</p> <p>Library features include:</p> <ul> <li>Primitives to express your app as a Type System</li> <li>Validation and introspection of this Type System (for compatibility with tools like GraphiQL)</li> <li>Parsing, validating and executing GraphQL queries against this Type System</li> <li>Rich error reporting, including query validation and execution errors</li> <li>Optional tools for parsing schema definition language</li> <li>Tools for batching requests to backend storage</li> <li>Async PHP platforms support via promises</li> <li>Standard HTTP server</li> </ul> <p>Also, several complementary tools are available which provide integrations with existing PHP frameworks, add support for Relay, etc.</p>"},{"location":"#current-status","title":"Current Status","text":"<p>The first version of this library (v0.1) was released on August 10th 2015.</p> <p>The current version supports all features described by GraphQL specification as well as some experimental features like schema definition language and schema printer.</p> <p>Ready for real-world usage.</p>"},{"location":"#github","title":"GitHub","text":"<p>Project source code is hosted on GitHub.</p>"},{"location":"class-reference/","title":"Class Reference","text":""},{"location":"class-reference/#graphqlgraphql","title":"GraphQL\\GraphQL","text":"<p>This is the primary facade for fulfilling GraphQL operations. See related documentation.</p> <p>@phpstan-import-type ArgsMapper from Executor @phpstan-import-type FieldResolver from Executor</p> <p>@see \\GraphQL\\Tests\\GraphQLTest</p>"},{"location":"class-reference/#graphqlgraphql-methods","title":"GraphQL\\GraphQL Methods","text":"<pre><code>/**\n * Executes graphql query.\n *\n * More sophisticated GraphQL servers, such as those which persist queries,\n * may wish to separate the validation and execution phases to a static time\n * tooling step, and a server runtime step.\n *\n * Available options:\n *\n * schema:\n *    The GraphQL type system to use when validating and executing a query.\n * source:\n *    A GraphQL language formatted string representing the requested operation.\n * rootValue:\n *    The value provided as the first argument to resolver functions on the top\n *    level type (e.g. the query object type).\n * contextValue:\n *    The context value is provided as an argument to resolver functions after\n *    field arguments. It is used to pass shared information useful at any point\n *    during executing this query, for example the currently logged in user and\n *    connections to databases or other services.\n *    If the passed object implements the `ScopedContext` interface,\n *    its `clone()` method will be called before passing the context down to a field.\n *    This allows passing information to child fields in the query tree without affecting sibling or parent fields.\n * variableValues:\n *    A mapping of variable name to runtime value to use for all variables\n *    defined in the requestString.\n * operationName:\n *    The name of the operation to use if requestString contains multiple\n *    possible operations. Can be omitted if requestString contains only\n *    one operation.\n * fieldResolver:\n *    A resolver function to use when one is not provided by the schema.\n *    If not provided, the default field resolver is used (which looks for a\n *    value on the source value with the field's name).\n * validationRules:\n *    A set of rules for query validation step. Default value is all available rules.\n *    Empty array would allow to skip query validation (may be convenient for persisted\n *    queries which are validated before persisting and assumed valid during execution)\n *\n * @param string|DocumentNode $source\n * @param mixed $rootValue\n * @param mixed $contextValue\n * @param array&lt;string, mixed&gt;|null $variableValues\n * @param array&lt;ValidationRule&gt;|null $validationRules\n *\n * @api\n *\n * @throws \\Exception\n * @throws InvariantViolation\n */\nstatic function executeQuery(\n    GraphQL\\Type\\Schema $schema,\n    $source,\n    $rootValue = null,\n    $contextValue = null,\n    ?array $variableValues = null,\n    ?string $operationName = null,\n    ?callable $fieldResolver = null,\n    ?array $validationRules = null\n): GraphQL\\Executor\\ExecutionResult\n</code></pre> <pre><code>/**\n * Same as executeQuery(), but requires PromiseAdapter and always returns a Promise.\n * Useful for Async PHP platforms.\n *\n * @param string|DocumentNode $source\n * @param mixed $rootValue\n * @param mixed $context\n * @param array&lt;string, mixed&gt;|null $variableValues\n * @param array&lt;ValidationRule&gt;|null $validationRules Defaults to using all available rules\n *\n * @api\n *\n * @throws \\Exception\n */\nstatic function promiseToExecute(\n    GraphQL\\Executor\\Promise\\PromiseAdapter $promiseAdapter,\n    GraphQL\\Type\\Schema $schema,\n    $source,\n    $rootValue = null,\n    $context = null,\n    ?array $variableValues = null,\n    ?string $operationName = null,\n    ?callable $fieldResolver = null,\n    ?array $validationRules = null\n): GraphQL\\Executor\\Promise\\Promise\n</code></pre> <pre><code>/**\n * Returns directives defined in GraphQL spec.\n *\n * @throws InvariantViolation\n *\n * @return array&lt;string, Directive&gt;\n *\n * @api\n */\nstatic function getStandardDirectives(): array\n</code></pre> <pre><code>/**\n * Returns types defined in GraphQL spec.\n *\n * @throws InvariantViolation\n *\n * @return array&lt;string, ScalarType&gt;\n *\n * @api\n */\nstatic function getStandardTypes(): array\n</code></pre> <pre><code>/**\n * Replaces standard types with types from this list (matching by name).\n *\n * Standard types not listed here remain untouched.\n *\n * @param array&lt;string, ScalarType&gt; $types\n *\n * @api\n *\n * @throws InvariantViolation\n */\nstatic function overrideStandardTypes(array $types): void\n</code></pre> <pre><code>/**\n * Returns standard validation rules implementing GraphQL spec.\n *\n * @return array&lt;class-string&lt;ValidationRule&gt;, ValidationRule&gt;\n *\n * @api\n */\nstatic function getStandardValidationRules(): array\n</code></pre> <pre><code>/**\n * Set default resolver implementation.\n *\n * @phpstan-param FieldResolver $fn\n *\n * @api\n */\nstatic function setDefaultFieldResolver(callable $fn): void\n</code></pre> <pre><code>/**\n * Set default args mapper implementation.\n *\n * @phpstan-param ArgsMapper $fn\n *\n * @api\n */\nstatic function setDefaultArgsMapper(callable $fn): void\n</code></pre>"},{"location":"class-reference/#graphqltypedefinitiontype","title":"GraphQL\\Type\\Definition\\Type","text":"<p>Registry of standard GraphQL types and base class for all other types.</p>"},{"location":"class-reference/#graphqltypedefinitiontype-methods","title":"GraphQL\\Type\\Definition\\Type Methods","text":"<pre><code>/**\n * Returns the registered or default standard Int type.\n *\n * @api\n */\nstatic function int(): GraphQL\\Type\\Definition\\ScalarType\n</code></pre> <pre><code>/**\n * Returns the registered or default standard Float type.\n *\n * @api\n */\nstatic function float(): GraphQL\\Type\\Definition\\ScalarType\n</code></pre> <pre><code>/**\n * Returns the registered or default standard String type.\n *\n * @api\n */\nstatic function string(): GraphQL\\Type\\Definition\\ScalarType\n</code></pre> <pre><code>/**\n * Returns the registered or default standard Boolean type.\n *\n * @api\n */\nstatic function boolean(): GraphQL\\Type\\Definition\\ScalarType\n</code></pre> <pre><code>/**\n * Returns the registered or default standard ID type.\n *\n * @api\n */\nstatic function id(): GraphQL\\Type\\Definition\\ScalarType\n</code></pre> <pre><code>/**\n * Wraps the given type in a list type.\n *\n * @template T of Type\n *\n * @param T|callable():T $type\n *\n * @return ListOfType&lt;T&gt;\n *\n * @api\n */\nstatic function listOf($type): GraphQL\\Type\\Definition\\ListOfType\n</code></pre> <pre><code>/**\n * Wraps the given type in a non-null type.\n *\n * @param NonNull|(NullableType&amp;Type)|callable():(NullableType&amp;Type) $type\n *\n * @api\n */\nstatic function nonNull($type): GraphQL\\Type\\Definition\\NonNull\n</code></pre> <pre><code>/**\n * Determines if the given type is an input type.\n *\n * @param mixed $type\n *\n * @api\n */\nstatic function isInputType($type): bool\n</code></pre> <pre><code>/**\n * Returns the underlying named type of the given type.\n *\n * @return (Type&amp;NamedType)|null\n *\n * @phpstan-return ($type is null ? null : Type&amp;NamedType)\n *\n * @api\n */\nstatic function getNamedType(?GraphQL\\Type\\Definition\\Type $type): ?GraphQL\\Type\\Definition\\Type\n</code></pre> <pre><code>/**\n * Determines if the given type is an output type.\n *\n * @param mixed $type\n *\n * @api\n */\nstatic function isOutputType($type): bool\n</code></pre> <pre><code>/**\n * Determines if the given type is a leaf type.\n *\n * @param mixed $type\n *\n * @api\n */\nstatic function isLeafType($type): bool\n</code></pre> <pre><code>/**\n * Determines if the given type is a composite type.\n *\n * @param mixed $type\n *\n * @api\n */\nstatic function isCompositeType($type): bool\n</code></pre> <pre><code>/**\n * Determines if the given type is an abstract type.\n *\n * @param mixed $type\n *\n * @api\n */\nstatic function isAbstractType($type): bool\n</code></pre> <pre><code>/**\n * Unwraps a potentially non-null type to return the underlying nullable type.\n *\n * @return Type&amp;NullableType\n *\n * @api\n */\nstatic function getNullableType(GraphQL\\Type\\Definition\\Type $type): GraphQL\\Type\\Definition\\Type\n</code></pre>"},{"location":"class-reference/#graphqltypedefinitionresolveinfo","title":"GraphQL\\Type\\Definition\\ResolveInfo","text":"<p>Structure containing information useful for field resolution process.</p> <p>Passed as 4th argument to every field resolver. See docs on field resolving (data fetching).</p> <p>@phpstan-import-type QueryPlanOptions from QueryPlan</p> <p>@phpstan-type Path list"},{"location":"class-reference/#graphqltypedefinitionresolveinfo-props","title":"GraphQL\\Type\\Definition\\ResolveInfo Props","text":"<pre><code>/**\n * The definition of the field being resolved.\n *\n * @api\n */\npublic $fieldDefinition;\n\n/**\n * The name of the field being resolved.\n *\n * @api\n */\npublic $fieldName;\n\n/**\n * Expected return type of the field being resolved.\n *\n * @api\n */\npublic $returnType;\n\n/**\n * AST of all nodes referencing this field in the query.\n *\n * @api\n *\n * @var \\ArrayObject&lt;int, FieldNode&gt;\n */\npublic $fieldNodes;\n\n/**\n * Parent type of the field being resolved.\n *\n * @api\n */\npublic $parentType;\n\n/**\n * Path to this field from the very root value. When fields are aliased, the path includes aliases.\n *\n * @api\n *\n * @var list&lt;string|int&gt;\n *\n * @phpstan-var Path\n */\npublic $path;\n\n/**\n * Path to this field from the very root value. This will never include aliases.\n *\n * @api\n *\n * @var list&lt;string|int&gt;\n *\n * @phpstan-var Path\n */\npublic $unaliasedPath;\n\n/**\n * Instance of a schema used for execution.\n *\n * @api\n */\npublic $schema;\n\n/**\n * AST of all fragments defined in query.\n *\n * @api\n *\n * @var array&lt;string, FragmentDefinitionNode&gt;\n */\npublic $fragments;\n\n/**\n * Root value passed to query execution.\n *\n * @api\n *\n * @var mixed\n */\npublic $rootValue;\n\n/**\n * AST of operation definition node (query, mutation).\n *\n * @api\n */\npublic $operation;\n\n/**\n * Array of variables passed to query execution.\n *\n * @api\n *\n * @var array&lt;string, mixed&gt;\n */\npublic $variableValues;\n</code></pre>"},{"location":"class-reference/#graphqltypedefinitionresolveinfo-methods","title":"GraphQL\\Type\\Definition\\ResolveInfo Methods","text":"<pre><code>/**\n * Returns names of all fields selected in query for `$this-&gt;fieldName` up to `$depth` levels.\n *\n * Example:\n * {\n *   root {\n *     id\n *     nested {\n *       nested1\n *       nested2 {\n *         nested3\n *       }\n *     }\n *   }\n * }\n *\n * Given this ResolveInfo instance is a part of root field resolution, and $depth === 1,\n * this method will return:\n * [\n *     'id' =&gt; true,\n *     'nested' =&gt; [\n *         'nested1' =&gt; true,\n *         'nested2' =&gt; true,\n *     ],\n * ]\n *\n * This method does not consider conditional typed fragments.\n * Use it with care for fields of interface and union types.\n *\n * @param int $depth How many levels to include in the output beyond the first\n *\n * @return array&lt;string, mixed&gt;\n *\n * @api\n */\nfunction getFieldSelection(int $depth = 0): array\n</code></pre> <pre><code>/**\n * Returns names and args of all fields selected in query for `$this-&gt;fieldName` up to `$depth` levels, including aliases.\n *\n * The result maps original field names to a map of selections for that field, including aliases.\n * For each of those selections, you can find the following keys:\n * - \"args\" contains the passed arguments for this field/alias (not on an union inline fragment)\n * - \"type\" contains the related Type instance found (will be the same for all aliases of a field)\n * - \"selectionSet\" contains potential nested fields of this field/alias (only on ObjectType). The structure is recursive from here.\n * - \"unions\" contains potential object types contained in an UnionType (only on UnionType). The structure is recursive from here and will go through the selectionSet of the object types.\n *\n * Example:\n * {\n *   root {\n *     id\n *     nested {\n *      nested1(myArg: 1)\n *      nested1Bis: nested1\n *     }\n *     alias1: nested {\n *       nested1(myArg: 2, mySecondAg: \"test\")\n *     }\n *     myUnion(myArg: 3) {\n *       ...on Nested {\n *         nested1(myArg: 4)\n *       }\n *       ...on MyCustomObject {\n *         nested3\n *       }\n *     }\n *   }\n * }\n *\n * Given this ResolveInfo instance is a part of root field resolution,\n * $depth === 1,\n * and fields \"nested\" represents an ObjectType named \"Nested\",\n * this method will return:\n * [\n *     'id' =&gt; [\n *         'id' =&gt; [\n *              'args' =&gt; [],\n *              'type' =&gt; GraphQL\\Type\\Definition\\IntType Object ( ... )),\n *         ],\n *     ],\n *     'nested' =&gt; [\n *         'nested' =&gt; [\n *             'args' =&gt; [],\n *             'type' =&gt; GraphQL\\Type\\Definition\\ObjectType Object ( ... )),\n *             'selectionSet' =&gt; [\n *                 'nested1' =&gt; [\n *                     'nested1' =&gt; [\n *                          'args' =&gt; [\n *                              'myArg' =&gt; 1,\n *                          ],\n *                          'type' =&gt; GraphQL\\Type\\Definition\\StringType Object ( ... )),\n *                      ],\n *                      'nested1Bis' =&gt; [\n *                          'args' =&gt; [],\n *                          'type' =&gt; GraphQL\\Type\\Definition\\StringType Object ( ... )),\n *                      ],\n *                 ],\n *             ],\n *         ],\n *     ],\n *     'alias1' =&gt; [\n *         'alias1' =&gt; [\n *             'args' =&gt; [],\n *             'type' =&gt; GraphQL\\Type\\Definition\\ObjectType Object ( ... )),\n *             'selectionSet' =&gt; [\n *                 'nested1' =&gt; [\n *                     'nested1' =&gt; [\n *                          'args' =&gt; [\n *                              'myArg' =&gt; 2,\n *                              'mySecondAg' =&gt; \"test\",\n *                          ],\n *                          'type' =&gt; GraphQL\\Type\\Definition\\StringType Object ( ... )),\n *                      ],\n *                 ],\n *             ],\n *         ],\n *     ],\n *     'myUnion' =&gt; [\n *         'myUnion' =&gt; [\n *              'args' =&gt; [\n *                  'myArg' =&gt; 3,\n *              ],\n *              'type' =&gt; GraphQL\\Type\\Definition\\UnionType Object ( ... )),\n *              'unions' =&gt; [\n *                  'Nested' =&gt; [\n *                      'type' =&gt; GraphQL\\Type\\Definition\\ObjectType Object ( ... )),\n *                      'selectionSet' =&gt; [\n *                          'nested1' =&gt; [\n *                              'nested1' =&gt; [\n *                                  'args' =&gt; [\n *                                      'myArg' =&gt; 4,\n *                                  ],\n *                                  'type' =&gt; GraphQL\\Type\\Definition\\StringType Object ( ... )),\n *                              ],\n *                          ],\n *                      ],\n *                  ],\n *                  'MyCustomObject' =&gt; [\n *                       'type' =&gt; GraphQL\\Tests\\Type\\TestClasses\\MyCustomType Object ( ... )),\n *                       'selectionSet' =&gt; [\n *                           'nested3' =&gt; [\n *                               'nested3' =&gt; [\n *                                   'args' =&gt; [],\n *                                   'type' =&gt; GraphQL\\Type\\Definition\\StringType Object ( ... )),\n *                               ],\n *                           ],\n *                       ],\n *                   ],\n *              ],\n *          ],\n *      ],\n * ]\n *\n * @param int $depth How many levels to include in the output beyond the first\n *\n * @throws \\Exception\n * @throws Error\n * @throws InvariantViolation\n *\n * @return array&lt;string, mixed&gt;\n *\n * @api\n */\nfunction getFieldSelectionWithAliases(int $depth = 0): array\n</code></pre>"},{"location":"class-reference/#graphqllanguagedirectivelocation","title":"GraphQL\\Language\\DirectiveLocation","text":"<p>Enumeration of available directive locations.</p>"},{"location":"class-reference/#graphqllanguagedirectivelocation-constants","title":"GraphQL\\Language\\DirectiveLocation Constants","text":"<pre><code>const QUERY = 'QUERY';\nconst MUTATION = 'MUTATION';\nconst SUBSCRIPTION = 'SUBSCRIPTION';\nconst FIELD = 'FIELD';\nconst FRAGMENT_DEFINITION = 'FRAGMENT_DEFINITION';\nconst FRAGMENT_SPREAD = 'FRAGMENT_SPREAD';\nconst INLINE_FRAGMENT = 'INLINE_FRAGMENT';\nconst VARIABLE_DEFINITION = 'VARIABLE_DEFINITION';\nconst EXECUTABLE_LOCATIONS = [\n    'QUERY' =&gt; 'QUERY',\n    'MUTATION' =&gt; 'MUTATION',\n    'SUBSCRIPTION' =&gt; 'SUBSCRIPTION',\n    'FIELD' =&gt; 'FIELD',\n    'FRAGMENT_DEFINITION' =&gt; 'FRAGMENT_DEFINITION',\n    'FRAGMENT_SPREAD' =&gt; 'FRAGMENT_SPREAD',\n    'INLINE_FRAGMENT' =&gt; 'INLINE_FRAGMENT',\n    'VARIABLE_DEFINITION' =&gt; 'VARIABLE_DEFINITION',\n];\nconst SCHEMA = 'SCHEMA';\nconst SCALAR = 'SCALAR';\nconst OBJECT = 'OBJECT';\nconst FIELD_DEFINITION = 'FIELD_DEFINITION';\nconst ARGUMENT_DEFINITION = 'ARGUMENT_DEFINITION';\nconst IFACE = 'INTERFACE';\nconst UNION = 'UNION';\nconst ENUM = 'ENUM';\nconst ENUM_VALUE = 'ENUM_VALUE';\nconst INPUT_OBJECT = 'INPUT_OBJECT';\nconst INPUT_FIELD_DEFINITION = 'INPUT_FIELD_DEFINITION';\nconst TYPE_SYSTEM_LOCATIONS = [\n    'SCHEMA' =&gt; 'SCHEMA',\n    'SCALAR' =&gt; 'SCALAR',\n    'OBJECT' =&gt; 'OBJECT',\n    'FIELD_DEFINITION' =&gt; 'FIELD_DEFINITION',\n    'ARGUMENT_DEFINITION' =&gt; 'ARGUMENT_DEFINITION',\n    'INTERFACE' =&gt; 'INTERFACE',\n    'UNION' =&gt; 'UNION',\n    'ENUM' =&gt; 'ENUM',\n    'ENUM_VALUE' =&gt; 'ENUM_VALUE',\n    'INPUT_OBJECT' =&gt; 'INPUT_OBJECT',\n    'INPUT_FIELD_DEFINITION' =&gt; 'INPUT_FIELD_DEFINITION',\n];\nconst LOCATIONS = [\n    'QUERY' =&gt; 'QUERY',\n    'MUTATION' =&gt; 'MUTATION',\n    'SUBSCRIPTION' =&gt; 'SUBSCRIPTION',\n    'FIELD' =&gt; 'FIELD',\n    'FRAGMENT_DEFINITION' =&gt; 'FRAGMENT_DEFINITION',\n    'FRAGMENT_SPREAD' =&gt; 'FRAGMENT_SPREAD',\n    'INLINE_FRAGMENT' =&gt; 'INLINE_FRAGMENT',\n    'VARIABLE_DEFINITION' =&gt; 'VARIABLE_DEFINITION',\n    'SCHEMA' =&gt; 'SCHEMA',\n    'SCALAR' =&gt; 'SCALAR',\n    'OBJECT' =&gt; 'OBJECT',\n    'FIELD_DEFINITION' =&gt; 'FIELD_DEFINITION',\n    'ARGUMENT_DEFINITION' =&gt; 'ARGUMENT_DEFINITION',\n    'INTERFACE' =&gt; 'INTERFACE',\n    'UNION' =&gt; 'UNION',\n    'ENUM' =&gt; 'ENUM',\n    'ENUM_VALUE' =&gt; 'ENUM_VALUE',\n    'INPUT_OBJECT' =&gt; 'INPUT_OBJECT',\n    'INPUT_FIELD_DEFINITION' =&gt; 'INPUT_FIELD_DEFINITION',\n];\n</code></pre>"},{"location":"class-reference/#graphqltypeschemaconfig","title":"GraphQL\\Type\\SchemaConfig","text":"<p>Configuration options for schema construction.</p> <p>The options accepted by the create method are described in the schema definition docs.</p> <p>Usage example:</p> <pre><code>$config = SchemaConfig::create()\n    -&gt;setQuery($myQueryType)\n    -&gt;setTypeLoader($myTypeLoader);\n\n$schema = new Schema($config);\n</code></pre> <p>@see Type, NamedType</p> <p>@phpstan-type MaybeLazyObjectType ObjectType|(callable(): (ObjectType|null))|null @phpstan-type TypeLoader callable(string $typeName): ((Type&amp;NamedType)|null) @phpstan-type Types iterable|(callable(): iterable)|iterable&lt;(callable(): Type&amp;NamedType)&gt;|(callable(): iterable&lt;(callable(): Type&amp;NamedType)&gt;) @phpstan-type SchemaConfigOptions array{ query?: MaybeLazyObjectType, mutation?: MaybeLazyObjectType, subscription?: MaybeLazyObjectType, types?: Types|null, directives?: array|null, typeLoader?: TypeLoader|null, assumeValid?: bool|null, astNode?: SchemaDefinitionNode|null, extensionASTNodes?: array|null, }"},{"location":"class-reference/#graphqltypeschemaconfig-methods","title":"GraphQL\\Type\\SchemaConfig Methods","text":"<pre><code>/**\n * Converts an array of options to instance of SchemaConfig\n * (or just returns empty config when array is not passed).\n *\n * @phpstan-param SchemaConfigOptions $options\n *\n * @throws InvariantViolation\n *\n * @api\n */\nstatic function create(array $options = []): self\n</code></pre> <pre><code>/**\n * @return MaybeLazyObjectType\n *\n * @api\n */\nfunction getQuery()\n</code></pre> <pre><code>/**\n * @param MaybeLazyObjectType $query\n *\n * @throws InvariantViolation\n *\n * @api\n */\nfunction setQuery($query): self\n</code></pre> <pre><code>/**\n * @return MaybeLazyObjectType\n *\n * @api\n */\nfunction getMutation()\n</code></pre> <pre><code>/**\n * @param MaybeLazyObjectType $mutation\n *\n * @throws InvariantViolation\n *\n * @api\n */\nfunction setMutation($mutation): self\n</code></pre> <pre><code>/**\n * @return MaybeLazyObjectType\n *\n * @api\n */\nfunction getSubscription()\n</code></pre> <pre><code>/**\n * @param MaybeLazyObjectType $subscription\n *\n * @throws InvariantViolation\n *\n * @api\n */\nfunction setSubscription($subscription): self\n</code></pre> <pre><code>/**\n * @return array|callable\n *\n * @phpstan-return Types\n *\n * @api\n */\nfunction getTypes()\n</code></pre> <pre><code>/**\n * @param array|callable $types\n *\n * @phpstan-param Types $types\n *\n * @api\n */\nfunction setTypes($types): self\n</code></pre> <pre><code>/**\n * @return array&lt;Directive&gt;|null\n *\n * @api\n */\nfunction getDirectives(): ?array\n</code></pre> <pre><code>/**\n * @param array&lt;Directive&gt;|null $directives\n *\n * @api\n */\nfunction setDirectives(?array $directives): self\n</code></pre> <pre><code>/**\n * @return callable|null $typeLoader\n *\n * @phpstan-return TypeLoader|null $typeLoader\n *\n * @api\n */\nfunction getTypeLoader(): ?callable\n</code></pre> <pre><code>/**\n * @phpstan-param TypeLoader|null $typeLoader\n *\n * @api\n */\nfunction setTypeLoader(?callable $typeLoader): self\n</code></pre>"},{"location":"class-reference/#graphqltypeschema","title":"GraphQL\\Type\\Schema","text":"<p>Schema Definition (see schema definition docs).</p> <p>A Schema is created by supplying the root types of each type of operation: query, mutation (optional) and subscription (optional). A schema definition is then supplied to the validator and executor. Usage Example:</p> <pre><code>$schema = new GraphQL\\Type\\Schema([\n  'query' =&gt; $MyAppQueryRootType,\n  'mutation' =&gt; $MyAppMutationRootType,\n]);\n</code></pre> <p>Or using Schema Config instance:</p> <pre><code>$config = GraphQL\\Type\\SchemaConfig::create()\n    -&gt;setQuery($MyAppQueryRootType)\n    -&gt;setMutation($MyAppMutationRootType);\n\n$schema = new GraphQL\\Type\\Schema($config);\n</code></pre> <p>@phpstan-import-type SchemaConfigOptions from SchemaConfig @phpstan-import-type OperationType from OperationDefinitionNode</p> <p>@see \\GraphQL\\Tests\\Type\\SchemaTest</p>"},{"location":"class-reference/#graphqltypeschema-methods","title":"GraphQL\\Type\\Schema Methods","text":"<pre><code>/**\n * @param SchemaConfig|array&lt;string, mixed&gt; $config\n *\n * @phpstan-param SchemaConfig|SchemaConfigOptions $config\n *\n * @throws InvariantViolation\n *\n * @api\n */\nfunction __construct($config)\n</code></pre> <pre><code>/**\n * Returns all types in this schema.\n *\n * This operation requires a full schema scan. Do not use in production environment.\n *\n * @throws InvariantViolation\n *\n * @return array&lt;string, Type&amp;NamedType&gt; Keys represent type names, values are instances of corresponding type definitions\n *\n * @api\n */\nfunction getTypeMap(): array\n</code></pre> <pre><code>/**\n * Returns a list of directives supported by this schema.\n *\n * @throws InvariantViolation\n *\n * @return array&lt;Directive&gt;\n *\n * @api\n */\nfunction getDirectives(): array\n</code></pre> <pre><code>/**\n * Returns root query type.\n *\n * @api\n */\nfunction getQueryType(): ?GraphQL\\Type\\Definition\\ObjectType\n</code></pre> <pre><code>/**\n * Returns root mutation type.\n *\n * @api\n */\nfunction getMutationType(): ?GraphQL\\Type\\Definition\\ObjectType\n</code></pre> <pre><code>/**\n * Returns schema subscription.\n *\n * @api\n */\nfunction getSubscriptionType(): ?GraphQL\\Type\\Definition\\ObjectType\n</code></pre> <pre><code>/**\n * Returns a type by name.\n *\n * @throws InvariantViolation\n *\n * @return (Type&amp;NamedType)|null\n *\n * @api\n */\nfunction getType(string $name): ?GraphQL\\Type\\Definition\\Type\n</code></pre> <pre><code>/**\n * Returns all possible concrete types for given abstract type\n * (implementations for interfaces and members of union type for unions).\n *\n * This operation requires full schema scan. Do not use in production environment.\n *\n * @param AbstractType&amp;Type $abstractType\n *\n * @throws InvariantViolation\n *\n * @return array&lt;ObjectType&gt;\n *\n * @api\n */\nfunction getPossibleTypes(GraphQL\\Type\\Definition\\AbstractType $abstractType): array\n</code></pre> <pre><code>/**\n * Returns all types that implement a given interface type.\n *\n * This operation requires full schema scan. Do not use in production environment.\n *\n * @api\n *\n * @throws InvariantViolation\n */\nfunction getImplementations(GraphQL\\Type\\Definition\\InterfaceType $abstractType): GraphQL\\Utils\\InterfaceImplementations\n</code></pre> <pre><code>/**\n * Returns true if the given type is a sub type of the given abstract type.\n *\n * @param AbstractType&amp;Type $abstractType\n * @param ImplementingType&amp;Type $maybeSubType\n *\n * @api\n *\n * @throws InvariantViolation\n */\nfunction isSubType(\n    GraphQL\\Type\\Definition\\AbstractType $abstractType,\n    GraphQL\\Type\\Definition\\ImplementingType $maybeSubType\n): bool\n</code></pre> <pre><code>/**\n * Returns instance of directive by name.\n *\n * @api\n *\n * @throws InvariantViolation\n */\nfunction getDirective(string $name): ?GraphQL\\Type\\Definition\\Directive\n</code></pre> <pre><code>/**\n * Throws if the schema is not valid.\n *\n * This operation requires a full schema scan. Do not use in production environment.\n *\n * @throws Error\n * @throws InvariantViolation\n *\n * @api\n */\nfunction assertValid(): void\n</code></pre> <pre><code>/**\n * Validate the schema and return any errors.\n *\n * This operation requires a full schema scan. Do not use in production environment.\n *\n * @throws InvariantViolation\n *\n * @return array&lt;int, Error&gt;\n *\n * @api\n */\nfunction validate(): array\n</code></pre>"},{"location":"class-reference/#graphqllanguageparser","title":"GraphQL\\Language\\Parser","text":"<p>Parses string containing GraphQL query language or schema definition language to Abstract Syntax Tree.</p> <p>@phpstan-type ParserOptions array{ noLocation?: bool, allowLegacySDLEmptyFields?: bool, allowLegacySDLImplementsInterfaces?: bool, experimentalFragmentVariables?: bool }</p> <p>noLocation: (By default, the parser creates AST nodes that know the location in the source that they correspond to. This configuration flag disables that behavior for performance or testing.)</p> <p>allowLegacySDLEmptyFields: If enabled, the parser will parse empty fields sets in the Schema Definition Language. Otherwise, the parser will follow the current specification.</p> <p>This option is provided to ease adoption of the final SDL specification and will be removed in a future major release.</p> <p>allowLegacySDLImplementsInterfaces: If enabled, the parser will parse implemented interfaces with no <code>&amp;</code> character between each interface. Otherwise, the parser will follow the current specification.</p> <p>This option is provided to ease adoption of the final SDL specification and will be removed in a future major release.</p> <p>experimentalFragmentVariables: (If enabled, the parser will understand and parse variable definitions contained in a fragment definition. They'll be represented in the <code>variableDefinitions</code> field of the FragmentDefinitionNode.</p> <p>The syntax is identical to normal, query-defined variables. For example:</p> <pre><code>fragment A($var: Boolean = false) on T  {\n  ...\n}\n</code></pre> <p>Note: this feature is experimental and may change or be removed in the future.) Those magic functions allow partial parsing:</p> <p>@method static NameNode name(Source|string $source, ParserOptions $options = []) @method static ExecutableDefinitionNode|TypeSystemDefinitionNode definition(Source|string $source, ParserOptions $options = []) @method static ExecutableDefinitionNode executableDefinition(Source|string $source, ParserOptions $options = []) @method static OperationDefinitionNode operationDefinition(Source|string $source, ParserOptions $options = []) @method static string operationType(Source|string $source, ParserOptions $options = []) @method static NodeList variableDefinitions(Source|string $source, ParserOptions $options = []) @method static VariableDefinitionNode variableDefinition(Source|string $source, ParserOptions $options = []) @method static VariableNode variable(Source|string $source, ParserOptions $options = []) @method static SelectionSetNode selectionSet(Source|string $source, ParserOptions $options = []) @method static mixed selection(Source|string $source, ParserOptions $options = []) @method static FieldNode field(Source|string $source, ParserOptions $options = []) @method static NodeList arguments(Source|string $source, ParserOptions $options = []) @method static NodeList constArguments(Source|string $source, ParserOptions $options = []) @method static ArgumentNode argument(Source|string $source, ParserOptions $options = []) @method static ArgumentNode constArgument(Source|string $source, ParserOptions $options = []) @method static FragmentSpreadNode|InlineFragmentNode fragment(Source|string $source, ParserOptions $options = []) @method static FragmentDefinitionNode fragmentDefinition(Source|string $source, ParserOptions $options = []) @method static NameNode fragmentName(Source|string $source, ParserOptions $options = []) @method static BooleanValueNode|EnumValueNode|FloatValueNode|IntValueNode|ListValueNode|NullValueNode|ObjectValueNode|StringValueNode|VariableNode valueLiteral(Source|string $source, ParserOptions $options = []) @method static BooleanValueNode|EnumValueNode|FloatValueNode|IntValueNode|ListValueNode|NullValueNode|ObjectValueNode|StringValueNode constValueLiteral(Source|string $source, ParserOptions $options = []) @method static StringValueNode stringLiteral(Source|string $source, ParserOptions $options = []) @method static BooleanValueNode|EnumValueNode|FloatValueNode|IntValueNode|StringValueNode constValue(Source|string $source, ParserOptions $options = []) @method static BooleanValueNode|EnumValueNode|FloatValueNode|IntValueNode|ListValueNode|ObjectValueNode|StringValueNode|VariableNode variableValue(Source|string $source, ParserOptions $options = []) @method static ListValueNode array(Source|string $source, ParserOptions $options = []) @method static ListValueNode constArray(Source|string $source, ParserOptions $options = []) @method static ObjectValueNode object(Source|string $source, ParserOptions $options = []) @method static ObjectValueNode constObject(Source|string $source, ParserOptions $options = []) @method static ObjectFieldNode objectField(Source|string $source, ParserOptions $options = []) @method static ObjectFieldNode constObjectField(Source|string $source, ParserOptions $options = []) @method static NodeList directives(Source|string $source, ParserOptions $options = []) @method static NodeList constDirectives(Source|string $source, ParserOptions $options = []) @method static DirectiveNode directive(Source|string $source, ParserOptions $options = []) @method static DirectiveNode constDirective(Source|string $source, ParserOptions $options = []) @method static ListTypeNode|NamedTypeNode|NonNullTypeNode typeReference(Source|string $source, ParserOptions $options = []) @method static NamedTypeNode namedType(Source|string $source, ParserOptions $options = []) @method static TypeSystemDefinitionNode typeSystemDefinition(Source|string $source, ParserOptions $options = []) @method static StringValueNode|null description(Source|string $source, ParserOptions $options = []) @method static SchemaDefinitionNode schemaDefinition(Source|string $source, ParserOptions $options = []) @method static OperationTypeDefinitionNode operationTypeDefinition(Source|string $source, ParserOptions $options = []) @method static ScalarTypeDefinitionNode scalarTypeDefinition(Source|string $source, ParserOptions $options = []) @method static ObjectTypeDefinitionNode objectTypeDefinition(Source|string $source, ParserOptions $options = []) @method static NodeList implementsInterfaces(Source|string $source, ParserOptions $options = []) @method static NodeList fieldsDefinition(Source|string $source, ParserOptions $options = []) @method static FieldDefinitionNode fieldDefinition(Source|string $source, ParserOptions $options = []) @method static NodeList argumentsDefinition(Source|string $source, ParserOptions $options = []) @method static InputValueDefinitionNode inputValueDefinition(Source|string $source, ParserOptions $options = []) @method static InterfaceTypeDefinitionNode interfaceTypeDefinition(Source|string $source, ParserOptions $options = []) @method static UnionTypeDefinitionNode unionTypeDefinition(Source|string $source, ParserOptions $options = []) @method static NodeList unionMemberTypes(Source|string $source, ParserOptions $options = []) @method static EnumTypeDefinitionNode enumTypeDefinition(Source|string $source, ParserOptions $options = []) @method static NodeList enumValuesDefinition(Source|string $source, ParserOptions $options = []) @method static EnumValueDefinitionNode enumValueDefinition(Source|string $source, ParserOptions $options = []) @method static InputObjectTypeDefinitionNode inputObjectTypeDefinition(Source|string $source, ParserOptions $options = []) @method static NodeList inputFieldsDefinition(Source|string $source, ParserOptions $options = []) @method static TypeExtensionNode typeExtension(Source|string $source, ParserOptions $options = []) @method static SchemaExtensionNode schemaTypeExtension(Source|string $source, ParserOptions $options = []) @method static ScalarTypeExtensionNode scalarTypeExtension(Source|string $source, ParserOptions $options = []) @method static ObjectTypeExtensionNode objectTypeExtension(Source|string $source, ParserOptions $options = []) @method static InterfaceTypeExtensionNode interfaceTypeExtension(Source|string $source, ParserOptions $options = []) @method static UnionTypeExtensionNode unionTypeExtension(Source|string $source, ParserOptions $options = []) @method static EnumTypeExtensionNode enumTypeExtension(Source|string $source, ParserOptions $options = []) @method static InputObjectTypeExtensionNode inputObjectTypeExtension(Source|string $source, ParserOptions $options = []) @method static DirectiveDefinitionNode directiveDefinition(Source|string $source, ParserOptions $options = []) @method static NodeList directiveLocations(Source|string $source, ParserOptions $options = []) @method static NameNode directiveLocation(Source|string $source, ParserOptions $options = []) <p>@see \\GraphQL\\Tests\\Language\\ParserTest</p>"},{"location":"class-reference/#graphqllanguageparser-methods","title":"GraphQL\\Language\\Parser Methods","text":"<pre><code>/**\n * Given a GraphQL source, parses it into a `GraphQL\\Language\\AST\\DocumentNode`.\n *\n * Throws `GraphQL\\Error\\SyntaxError` if a syntax error is encountered.\n *\n * @param Source|string $source\n *\n * @phpstan-param ParserOptions $options\n *\n * @api\n *\n * @throws \\JsonException\n * @throws SyntaxError\n */\nstatic function parse($source, array $options = []): GraphQL\\Language\\AST\\DocumentNode\n</code></pre> <pre><code>/**\n * Given a string containing a GraphQL value (ex. `[42]`), parse the AST for that value.\n *\n * Throws `GraphQL\\Error\\SyntaxError` if a syntax error is encountered.\n *\n * This is useful within tools that operate upon GraphQL Values directly and\n * in isolation of complete GraphQL documents.\n *\n * Consider providing the results to the utility function: `GraphQL\\Utils\\AST::valueFromAST()`.\n *\n * @param Source|string $source\n *\n * @phpstan-param ParserOptions $options\n *\n * @throws \\JsonException\n * @throws SyntaxError\n *\n * @return BooleanValueNode|EnumValueNode|FloatValueNode|IntValueNode|ListValueNode|NullValueNode|ObjectValueNode|StringValueNode|VariableNode\n *\n * @api\n */\nstatic function parseValue($source, array $options = [])\n</code></pre> <pre><code>/**\n * Given a string containing a GraphQL Type (ex. `[Int!]`), parse the AST for that type.\n *\n * Throws `GraphQL\\Error\\SyntaxError` if a syntax error is encountered.\n *\n * This is useful within tools that operate upon GraphQL Types directly and\n * in isolation of complete GraphQL documents.\n *\n * Consider providing the results to the utility function: `GraphQL\\Utils\\AST::typeFromAST()`.\n *\n * @param Source|string $source\n *\n * @phpstan-param ParserOptions $options\n *\n * @throws \\JsonException\n * @throws SyntaxError\n *\n * @return ListTypeNode|NamedTypeNode|NonNullTypeNode\n *\n * @api\n */\nstatic function parseType($source, array $options = [])\n</code></pre>"},{"location":"class-reference/#graphqllanguageprinter","title":"GraphQL\\Language\\Printer","text":"<p>Prints AST to string. Capable of printing GraphQL queries and Type definition language. Useful for pretty-printing queries or printing back AST for logging, documentation, etc.</p> <p>Usage example:</p> <pre><code>$query = 'query myQuery {someField}';\n$ast = GraphQL\\Language\\Parser::parse($query);\n$printed = GraphQL\\Language\\Printer::doPrint($ast);\n</code></pre> <p>@see \\GraphQL\\Tests\\Language\\PrinterTest</p>"},{"location":"class-reference/#graphqllanguageprinter-methods","title":"GraphQL\\Language\\Printer Methods","text":"<pre><code>/**\n * Converts the AST of a GraphQL node to a string.\n *\n * Handles both executable definitions and schema definitions.\n *\n * @throws \\JsonException\n *\n * @api\n */\nstatic function doPrint(GraphQL\\Language\\AST\\Node $ast): string\n</code></pre>"},{"location":"class-reference/#graphqllanguagevisitor","title":"GraphQL\\Language\\Visitor","text":"<p>Utility for efficient AST traversal and modification.</p> <p><code>visit()</code> will walk through an AST using a depth first traversal, calling the visitor's enter function at each node in the traversal, and calling the leave function after visiting that node and all of its child nodes.</p> <p>By returning different values from the <code>enter</code> and <code>leave</code> functions, the behavior of the visitor can be altered.</p> <ul> <li>no return (<code>void</code>) or return <code>null</code>: no action</li> <li><code>Visitor::skipNode()</code>: skips over the subtree at the current node of the AST</li> <li><code>Visitor::stop()</code>: stop the Visitor completely</li> <li><code>Visitor::removeNode()</code>: remove the current node</li> <li>return any other value: replace this node with the returned value</li> </ul> <p>When using <code>visit()</code> to edit an AST, the original AST will not be modified, and a new version of the AST with the changes applied will be returned from the visit function.</p> <p>$editedAST = Visitor::visit($ast, [ 'enter' =&gt; function (Node $node, $key, $parent, array $path, array $ancestors) { // ... }, 'leave' =&gt; function (Node $node, $key, $parent, array $path, array $ancestors) { // ... } ]);</p> <p>Alternatively to providing <code>enter</code> and <code>leave</code> functions, a visitor can instead provide functions named the same as the kinds of AST nodes, or enter/leave visitors at a named key, leading to four permutations of visitor API:</p> <ol> <li>Named visitors triggered when entering a node a specific kind.</li> </ol> <p>Visitor::visit($ast, [    NodeKind::OBJECT_TYPE_DEFINITION =&gt; function (ObjectTypeDefinitionNode $node) {    // enter the \"ObjectTypeDefinition\" node    }    ]);</p> <ol> <li>Named visitors that trigger upon entering and leaving a node of    a specific kind.</li> </ol> <p>Visitor::visit($ast, [    NodeKind::OBJECT_TYPE_DEFINITION =&gt; [    'enter' =&gt; function (ObjectTypeDefinitionNode $node) {    // enter the \"ObjectTypeDefinition\" node    }    'leave' =&gt; function (ObjectTypeDefinitionNode $node) {    // leave the \"ObjectTypeDefinition\" node    }    ]    ]);</p> <ol> <li>Generic visitors that trigger upon entering and leaving any node.</li> </ol> <p>Visitor::visit($ast, [    'enter' =&gt; function (Node $node) {    // enter any node    },    'leave' =&gt; function (Node $node) {    // leave any node    }    ]);</p> <ol> <li>Parallel visitors for entering and leaving nodes of a specific kind.</li> </ol> <p>Visitor::visit($ast, [    'enter' =&gt; [    NodeKind::OBJECT_TYPE_DEFINITION =&gt; function (ObjectTypeDefinitionNode $node) {    // enter the \"ObjectTypeDefinition\" node    }    },    'leave' =&gt; [    NodeKind::OBJECT_TYPE_DEFINITION =&gt; function (ObjectTypeDefinitionNode $node) {    // leave the \"ObjectTypeDefinition\" node    }    ]    ]);</p> <p>@phpstan-type NodeVisitor callable(Node): (VisitorOperation|Node|NodeList|null|false|void) @phpstan-type VisitorArray array|array&gt; <p>@see \\GraphQL\\Tests\\Language\\VisitorTest</p>"},{"location":"class-reference/#graphqllanguagevisitor-methods","title":"GraphQL\\Language\\Visitor Methods","text":"<pre><code>/**\n * Visit the AST (see class description for details).\n *\n * @param NodeList&lt;Node&gt;|Node $root\n * @param VisitorArray $visitor\n * @param array&lt;string, mixed&gt;|null $keyMap\n *\n * @throws \\Exception\n *\n * @return mixed\n *\n * @api\n */\nstatic function visit(object $root, array $visitor, ?array $keyMap = null)\n</code></pre> <pre><code>/**\n * Returns marker for stopping.\n *\n * @api\n */\nstatic function stop(): GraphQL\\Language\\VisitorStop\n</code></pre> <pre><code>/**\n * Returns marker for skipping the subtree at the current node.\n *\n * @api\n */\nstatic function skipNode(): GraphQL\\Language\\VisitorSkipNode\n</code></pre> <pre><code>/**\n * Returns marker for removing the current node.\n *\n * @api\n */\nstatic function removeNode(): GraphQL\\Language\\VisitorRemoveNode\n</code></pre>"},{"location":"class-reference/#graphqllanguageastnodekind","title":"GraphQL\\Language\\AST\\NodeKind","text":"<p>Holds constants of possible AST nodes.</p>"},{"location":"class-reference/#graphqllanguageastnodekind-constants","title":"GraphQL\\Language\\AST\\NodeKind Constants","text":"<pre><code>const NAME = 'Name';\nconst DOCUMENT = 'Document';\nconst OPERATION_DEFINITION = 'OperationDefinition';\nconst VARIABLE_DEFINITION = 'VariableDefinition';\nconst VARIABLE = 'Variable';\nconst SELECTION_SET = 'SelectionSet';\nconst FIELD = 'Field';\nconst ARGUMENT = 'Argument';\nconst FRAGMENT_SPREAD = 'FragmentSpread';\nconst INLINE_FRAGMENT = 'InlineFragment';\nconst FRAGMENT_DEFINITION = 'FragmentDefinition';\nconst INT = 'IntValue';\nconst FLOAT = 'FloatValue';\nconst STRING = 'StringValue';\nconst BOOLEAN = 'BooleanValue';\nconst ENUM = 'EnumValue';\nconst NULL = 'NullValue';\nconst LST = 'ListValue';\nconst OBJECT = 'ObjectValue';\nconst OBJECT_FIELD = 'ObjectField';\nconst DIRECTIVE = 'Directive';\nconst NAMED_TYPE = 'NamedType';\nconst LIST_TYPE = 'ListType';\nconst NON_NULL_TYPE = 'NonNullType';\nconst SCHEMA_DEFINITION = 'SchemaDefinition';\nconst OPERATION_TYPE_DEFINITION = 'OperationTypeDefinition';\nconst SCALAR_TYPE_DEFINITION = 'ScalarTypeDefinition';\nconst OBJECT_TYPE_DEFINITION = 'ObjectTypeDefinition';\nconst FIELD_DEFINITION = 'FieldDefinition';\nconst INPUT_VALUE_DEFINITION = 'InputValueDefinition';\nconst INTERFACE_TYPE_DEFINITION = 'InterfaceTypeDefinition';\nconst UNION_TYPE_DEFINITION = 'UnionTypeDefinition';\nconst ENUM_TYPE_DEFINITION = 'EnumTypeDefinition';\nconst ENUM_VALUE_DEFINITION = 'EnumValueDefinition';\nconst INPUT_OBJECT_TYPE_DEFINITION = 'InputObjectTypeDefinition';\nconst SCALAR_TYPE_EXTENSION = 'ScalarTypeExtension';\nconst OBJECT_TYPE_EXTENSION = 'ObjectTypeExtension';\nconst INTERFACE_TYPE_EXTENSION = 'InterfaceTypeExtension';\nconst UNION_TYPE_EXTENSION = 'UnionTypeExtension';\nconst ENUM_TYPE_EXTENSION = 'EnumTypeExtension';\nconst INPUT_OBJECT_TYPE_EXTENSION = 'InputObjectTypeExtension';\nconst DIRECTIVE_DEFINITION = 'DirectiveDefinition';\nconst SCHEMA_EXTENSION = 'SchemaExtension';\nconst CLASS_MAP = [\n    'Name' =&gt; 'GraphQL\\\\Language\\\\AST\\\\NameNode',\n    'Document' =&gt; 'GraphQL\\\\Language\\\\AST\\\\DocumentNode',\n    'OperationDefinition' =&gt; 'GraphQL\\\\Language\\\\AST\\\\OperationDefinitionNode',\n    'VariableDefinition' =&gt; 'GraphQL\\\\Language\\\\AST\\\\VariableDefinitionNode',\n    'Variable' =&gt; 'GraphQL\\\\Language\\\\AST\\\\VariableNode',\n    'SelectionSet' =&gt; 'GraphQL\\\\Language\\\\AST\\\\SelectionSetNode',\n    'Field' =&gt; 'GraphQL\\\\Language\\\\AST\\\\FieldNode',\n    'Argument' =&gt; 'GraphQL\\\\Language\\\\AST\\\\ArgumentNode',\n    'FragmentSpread' =&gt; 'GraphQL\\\\Language\\\\AST\\\\FragmentSpreadNode',\n    'InlineFragment' =&gt; 'GraphQL\\\\Language\\\\AST\\\\InlineFragmentNode',\n    'FragmentDefinition' =&gt; 'GraphQL\\\\Language\\\\AST\\\\FragmentDefinitionNode',\n    'IntValue' =&gt; 'GraphQL\\\\Language\\\\AST\\\\IntValueNode',\n    'FloatValue' =&gt; 'GraphQL\\\\Language\\\\AST\\\\FloatValueNode',\n    'StringValue' =&gt; 'GraphQL\\\\Language\\\\AST\\\\StringValueNode',\n    'BooleanValue' =&gt; 'GraphQL\\\\Language\\\\AST\\\\BooleanValueNode',\n    'EnumValue' =&gt; 'GraphQL\\\\Language\\\\AST\\\\EnumValueNode',\n    'NullValue' =&gt; 'GraphQL\\\\Language\\\\AST\\\\NullValueNode',\n    'ListValue' =&gt; 'GraphQL\\\\Language\\\\AST\\\\ListValueNode',\n    'ObjectValue' =&gt; 'GraphQL\\\\Language\\\\AST\\\\ObjectValueNode',\n    'ObjectField' =&gt; 'GraphQL\\\\Language\\\\AST\\\\ObjectFieldNode',\n    'Directive' =&gt; 'GraphQL\\\\Language\\\\AST\\\\DirectiveNode',\n    'NamedType' =&gt; 'GraphQL\\\\Language\\\\AST\\\\NamedTypeNode',\n    'ListType' =&gt; 'GraphQL\\\\Language\\\\AST\\\\ListTypeNode',\n    'NonNullType' =&gt; 'GraphQL\\\\Language\\\\AST\\\\NonNullTypeNode',\n    'SchemaDefinition' =&gt; 'GraphQL\\\\Language\\\\AST\\\\SchemaDefinitionNode',\n    'OperationTypeDefinition' =&gt; 'GraphQL\\\\Language\\\\AST\\\\OperationTypeDefinitionNode',\n    'ScalarTypeDefinition' =&gt; 'GraphQL\\\\Language\\\\AST\\\\ScalarTypeDefinitionNode',\n    'ObjectTypeDefinition' =&gt; 'GraphQL\\\\Language\\\\AST\\\\ObjectTypeDefinitionNode',\n    'FieldDefinition' =&gt; 'GraphQL\\\\Language\\\\AST\\\\FieldDefinitionNode',\n    'InputValueDefinition' =&gt; 'GraphQL\\\\Language\\\\AST\\\\InputValueDefinitionNode',\n    'InterfaceTypeDefinition' =&gt; 'GraphQL\\\\Language\\\\AST\\\\InterfaceTypeDefinitionNode',\n    'UnionTypeDefinition' =&gt; 'GraphQL\\\\Language\\\\AST\\\\UnionTypeDefinitionNode',\n    'EnumTypeDefinition' =&gt; 'GraphQL\\\\Language\\\\AST\\\\EnumTypeDefinitionNode',\n    'EnumValueDefinition' =&gt; 'GraphQL\\\\Language\\\\AST\\\\EnumValueDefinitionNode',\n    'InputObjectTypeDefinition' =&gt; 'GraphQL\\\\Language\\\\AST\\\\InputObjectTypeDefinitionNode',\n    'ScalarTypeExtension' =&gt; 'GraphQL\\\\Language\\\\AST\\\\ScalarTypeExtensionNode',\n    'ObjectTypeExtension' =&gt; 'GraphQL\\\\Language\\\\AST\\\\ObjectTypeExtensionNode',\n    'InterfaceTypeExtension' =&gt; 'GraphQL\\\\Language\\\\AST\\\\InterfaceTypeExtensionNode',\n    'UnionTypeExtension' =&gt; 'GraphQL\\\\Language\\\\AST\\\\UnionTypeExtensionNode',\n    'EnumTypeExtension' =&gt; 'GraphQL\\\\Language\\\\AST\\\\EnumTypeExtensionNode',\n    'InputObjectTypeExtension' =&gt; 'GraphQL\\\\Language\\\\AST\\\\InputObjectTypeExtensionNode',\n    'DirectiveDefinition' =&gt; 'GraphQL\\\\Language\\\\AST\\\\DirectiveDefinitionNode',\n];\n</code></pre>"},{"location":"class-reference/#graphqlexecutorexecutor","title":"GraphQL\\Executor\\Executor","text":"<p>Implements the \"Evaluating requests\" section of the GraphQL specification.</p> <p>@phpstan-type ArgsMapper callable(array, FieldDefinition, FieldNode, mixed): mixed @phpstan-type FieldResolver callable(mixed, array, mixed, ResolveInfo): mixed @phpstan-type ImplementationFactory callable(PromiseAdapter, Schema, DocumentNode, mixed, mixed, array, ?string, callable, callable): ExecutorImplementation <p>@see \\GraphQL\\Tests\\Executor\\ExecutorTest</p>"},{"location":"class-reference/#graphqlexecutorexecutor-methods","title":"GraphQL\\Executor\\Executor Methods","text":"<pre><code>/**\n * Executes DocumentNode against given $schema.\n *\n * Always returns ExecutionResult and never throws.\n * All errors which occur during operation execution are collected in `$result-&gt;errors`.\n *\n * @param mixed $rootValue\n * @param mixed $contextValue\n * @param array&lt;string, mixed&gt;|null $variableValues\n *\n * @phpstan-param FieldResolver|null $fieldResolver\n *\n * @api\n *\n * @throws InvariantViolation\n */\nstatic function execute(\n    GraphQL\\Type\\Schema $schema,\n    GraphQL\\Language\\AST\\DocumentNode $documentNode,\n    $rootValue = null,\n    $contextValue = null,\n    ?array $variableValues = null,\n    ?string $operationName = null,\n    ?callable $fieldResolver = null\n): GraphQL\\Executor\\ExecutionResult\n</code></pre> <pre><code>/**\n * Same as execute(), but requires promise adapter and returns a promise which is always\n * fulfilled with an instance of ExecutionResult and never rejected.\n *\n * Useful for async PHP platforms.\n *\n * @param mixed $rootValue\n * @param mixed $contextValue\n * @param array&lt;string, mixed&gt;|null $variableValues\n *\n * @phpstan-param FieldResolver|null $fieldResolver\n * @phpstan-param ArgsMapper|null $argsMapper\n *\n * @api\n */\nstatic function promiseToExecute(\n    GraphQL\\Executor\\Promise\\PromiseAdapter $promiseAdapter,\n    GraphQL\\Type\\Schema $schema,\n    GraphQL\\Language\\AST\\DocumentNode $documentNode,\n    $rootValue = null,\n    $contextValue = null,\n    ?array $variableValues = null,\n    ?string $operationName = null,\n    ?callable $fieldResolver = null,\n    ?callable $argsMapper = null\n): GraphQL\\Executor\\Promise\\Promise\n</code></pre>"},{"location":"class-reference/#graphqlexecutorscopedcontext","title":"GraphQL\\Executor\\ScopedContext","text":"<p>When the object passed as <code>$contextValue</code> to GraphQL execution implements this, its <code>clone()</code> method will be called before passing the context down to a field. This allows passing information to child fields in the query tree without affecting sibling or parent fields.</p>"},{"location":"class-reference/#graphqlexecutorexecutionresult","title":"GraphQL\\Executor\\ExecutionResult","text":"<p>Returned after query execution. Represents both - result of successful execution and of a failed one (with errors collected in <code>errors</code> prop).</p> <p>Could be converted to spec-compliant serializable array using <code>toArray()</code>.</p> <p>@phpstan-type SerializableError array{ message: string, locations?: array, path?: array, extensions?: array } @phpstan-type SerializableErrors list @phpstan-type SerializableResult array{ data?: array, errors?: SerializableErrors, extensions?: array } @phpstan-type ErrorFormatter callable(\\Throwable): SerializableError @phpstan-type ErrorsHandler callable(list $errors, ErrorFormatter $formatter): SerializableErrors <p>@see \\GraphQL\\Tests\\Executor\\ExecutionResultTest</p>"},{"location":"class-reference/#graphqlexecutorexecutionresult-props","title":"GraphQL\\Executor\\ExecutionResult Props","text":"<pre><code>/**\n * Data collected from resolvers during query execution.\n *\n * @api\n *\n * @var array&lt;string, mixed&gt;|null\n */\npublic $data;\n\n/**\n * Errors registered during query execution.\n *\n * If an error was caused by exception thrown in resolver, $error-&gt;getPrevious() would\n * contain original exception.\n *\n * @api\n *\n * @var list&lt;Error&gt;\n */\npublic $errors;\n\n/**\n * User-defined serializable array of extensions included in serialized result.\n *\n * @api\n *\n * @var array&lt;string, mixed&gt;|null\n */\npublic $extensions;\n</code></pre>"},{"location":"class-reference/#graphqlexecutorexecutionresult-methods","title":"GraphQL\\Executor\\ExecutionResult Methods","text":"<pre><code>/**\n * Define custom error formatting (must conform to http://facebook.github.io/graphql/#sec-Errors).\n *\n * Expected signature is: function (GraphQL\\Error\\Error $error): array\n *\n * Default formatter is \"GraphQL\\Error\\FormattedError::createFromException\"\n *\n * Expected returned value must be an array:\n * array(\n *    'message' =&gt; 'errorMessage',\n *    // ... other keys\n * );\n *\n * @phpstan-param ErrorFormatter|null $errorFormatter\n *\n * @api\n */\nfunction setErrorFormatter(?callable $errorFormatter): self\n</code></pre> <pre><code>/**\n * Define custom logic for error handling (filtering, logging, etc).\n *\n * Expected handler signature is:\n * fn (array $errors, callable $formatter): array\n *\n * Default handler is:\n * fn (array $errors, callable $formatter): array =&gt; array_map($formatter, $errors)\n *\n * @phpstan-param ErrorsHandler|null $errorsHandler\n *\n * @api\n */\nfunction setErrorsHandler(?callable $errorsHandler): self\n</code></pre> <pre><code>/**\n * Converts GraphQL query result to spec-compliant serializable array using provided\n * errors handler and formatter.\n *\n * If debug argument is passed, output of error formatter is enriched which debugging information\n * (\"debugMessage\", \"trace\" keys depending on flags).\n *\n * $debug argument must sum of flags from @see \\GraphQL\\Error\\DebugFlag\n *\n * @phpstan-return SerializableResult\n *\n * @api\n */\nfunction toArray(int $debug = 'GraphQL\\\\Error\\\\DebugFlag::NONE'): array\n</code></pre>"},{"location":"class-reference/#graphqlexecutorpromisepromiseadapter","title":"GraphQL\\Executor\\Promise\\PromiseAdapter","text":"<p>Provides a means for integration of async PHP platforms (related docs).</p>"},{"location":"class-reference/#graphqlexecutorpromisepromiseadapter-methods","title":"GraphQL\\Executor\\Promise\\PromiseAdapter Methods","text":"<pre><code>/**\n * Is the value a promise or a deferred of the underlying platform?\n *\n * @param mixed $value\n *\n * @api\n */\nfunction isThenable($value): bool\n</code></pre> <pre><code>/**\n * Converts thenable of the underlying platform into GraphQL\\Executor\\Promise\\Promise instance.\n *\n * @param mixed $thenable\n *\n * @api\n */\nfunction convertThenable($thenable): GraphQL\\Executor\\Promise\\Promise\n</code></pre> <pre><code>/**\n * Accepts our Promise wrapper, extracts adopted promise out of it and executes actual `then` logic described\n * in Promises/A+ specs. Then returns new wrapped instance of GraphQL\\Executor\\Promise\\Promise.\n *\n * @api\n */\nfunction then(\n    GraphQL\\Executor\\Promise\\Promise $promise,\n    ?callable $onFulfilled = null,\n    ?callable $onRejected = null\n): GraphQL\\Executor\\Promise\\Promise\n</code></pre> <pre><code>/**\n * Creates a Promise from the given resolver callable.\n *\n * @param callable(callable $resolve, callable $reject): void $resolver\n *\n * @api\n */\nfunction create(callable $resolver): GraphQL\\Executor\\Promise\\Promise\n</code></pre> <pre><code>/**\n * Creates a fulfilled Promise for a value if the value is not a promise.\n *\n * @param mixed $value\n *\n * @api\n */\nfunction createFulfilled($value = null): GraphQL\\Executor\\Promise\\Promise\n</code></pre> <pre><code>/**\n * Creates a rejected promise for a reason if the reason is not a promise.\n *\n * If the provided reason is a promise, then it is returned as-is.\n *\n * @api\n */\nfunction createRejected(Throwable $reason): GraphQL\\Executor\\Promise\\Promise\n</code></pre> <pre><code>/**\n * Given an iterable of promises (or values), returns a promise that is fulfilled when all the\n * items in the iterable are fulfilled.\n *\n * @param iterable&lt;Promise|mixed&gt; $promisesOrValues\n *\n * @api\n */\nfunction all(iterable $promisesOrValues): GraphQL\\Executor\\Promise\\Promise\n</code></pre>"},{"location":"class-reference/#graphqlvalidatordocumentvalidator","title":"GraphQL\\Validator\\DocumentValidator","text":"<p>Implements the \"Validation\" section of the spec.</p> <p>Validation runs synchronously, returning an array of encountered errors, or an empty array if no errors were encountered and the document is valid.</p> <p>A list of specific validation rules may be provided. If not provided, the default list of rules defined by the GraphQL specification will be used.</p> <p>Each validation rule is an instance of GraphQL\\Validator\\Rules\\ValidationRule which returns a visitor (see the GraphQL\\Language\\Visitor API).</p> <p>Visitor methods are expected to return an instance of GraphQL\\Error\\Error, or array of such instances when invalid.</p> <p>Optionally a custom TypeInfo instance may be provided. If not provided, one will be created from the provided schema.</p>"},{"location":"class-reference/#graphqlvalidatordocumentvalidator-methods","title":"GraphQL\\Validator\\DocumentValidator Methods","text":"<pre><code>/**\n * Validate a GraphQL query against a schema.\n *\n * @param array&lt;ValidationRule&gt;|null $rules Defaults to using all available rules\n *\n * @throws \\Exception\n *\n * @return list&lt;Error&gt;\n *\n * @api\n */\nstatic function validate(\n    GraphQL\\Type\\Schema $schema,\n    GraphQL\\Language\\AST\\DocumentNode $ast,\n    ?array $rules = null,\n    ?GraphQL\\Utils\\TypeInfo $typeInfo = null\n): array\n</code></pre> <pre><code>/**\n * Returns all global validation rules.\n *\n * @throws \\InvalidArgumentException\n *\n * @return array&lt;string, ValidationRule&gt;\n *\n * @api\n */\nstatic function allRules(): array\n</code></pre> <pre><code>/**\n * Returns global validation rule by name.\n *\n * Standard rules are named by class name, so example usage for such rules:\n *\n * @example DocumentValidator::getRule(GraphQL\\Validator\\Rules\\QueryComplexity::class);\n *\n * @api\n *\n * @throws \\InvalidArgumentException\n */\nstatic function getRule(string $name): ?GraphQL\\Validator\\Rules\\ValidationRule\n</code></pre> <pre><code>/**\n * Add rule to list of global validation rules.\n *\n * @api\n */\nstatic function addRule(GraphQL\\Validator\\Rules\\ValidationRule $rule): void\n</code></pre> <pre><code>/**\n * Remove rule from list of global validation rules.\n *\n * @api\n */\nstatic function removeRule(GraphQL\\Validator\\Rules\\ValidationRule $rule): void\n</code></pre>"},{"location":"class-reference/#graphqlerrorerror","title":"GraphQL\\Error\\Error","text":"<p>Describes an Error found during the parse, validate, or execute phases of performing a GraphQL operation. In addition to a message and stack trace, it also includes information about the locations in a GraphQL document and/or execution result that correspond to the Error.</p> <p>When the error was caused by an exception thrown in resolver, original exception is available via <code>getPrevious()</code>.</p> <p>Also read related docs on error handling</p> <p>Class extends standard PHP <code>\\Exception</code>, so all standard methods of base <code>\\Exception</code> class are available in addition to those listed below.</p> <p>@see \\GraphQL\\Tests\\Error\\ErrorTest</p>"},{"location":"class-reference/#graphqlerrorerror-methods","title":"GraphQL\\Error\\Error Methods","text":"<pre><code>/**\n * An array of locations within the source GraphQL document which correspond to this error.\n *\n * Each entry has information about `line` and `column` within source GraphQL document:\n * $location-&gt;line;\n * $location-&gt;column;\n *\n * Errors during validation often contain multiple locations, for example to\n * point out to field mentioned in multiple fragments. Errors during execution include a\n * single location, the field which produced the error.\n *\n * @return array&lt;int, SourceLocation&gt;\n *\n * @api\n */\nfunction getLocations(): array\n</code></pre> <pre><code>/**\n * Returns an array describing the path from the root value to the field which produced this error.\n * Only included for execution errors. When fields are aliased, the path includes aliases.\n *\n * @return list&lt;int|string&gt;|null\n *\n * @api\n */\nfunction getPath(): ?array\n</code></pre> <pre><code>/**\n * Returns an array describing the path from the root value to the field which produced this error.\n * Only included for execution errors. This will never include aliases.\n *\n * @return list&lt;int|string&gt;|null\n *\n * @api\n */\nfunction getUnaliasedPath(): ?array\n</code></pre>"},{"location":"class-reference/#graphqlerrorwarning","title":"GraphQL\\Error\\Warning","text":"<p>Encapsulates warnings produced by the library.</p> <p>Warnings can be suppressed (individually or all) if required. Also, it is possible to override warning handler (which is trigger_error() by default).</p> <p>@phpstan-type WarningHandler callable(string $errorMessage, int $warningId, ?int $messageLevel): void</p>"},{"location":"class-reference/#graphqlerrorwarning-constants","title":"GraphQL\\Error\\Warning Constants","text":"<pre><code>const NONE = 0;\nconst WARNING_ASSIGN = 2;\nconst WARNING_CONFIG = 4;\nconst WARNING_FULL_SCHEMA_SCAN = 8;\nconst WARNING_CONFIG_DEPRECATION = 16;\nconst WARNING_NOT_A_TYPE = 32;\nconst ALL = 63;\n</code></pre>"},{"location":"class-reference/#graphqlerrorwarning-methods","title":"GraphQL\\Error\\Warning Methods","text":"<pre><code>/**\n * Sets warning handler which can intercept all system warnings.\n * When not set, trigger_error() is used to notify about warnings.\n *\n * @phpstan-param WarningHandler|null $warningHandler\n *\n * @api\n */\nstatic function setWarningHandler(?callable $warningHandler = null): void\n</code></pre> <pre><code>/**\n * Suppress warning by id (has no effect when custom warning handler is set).\n *\n * @param bool|int $suppress\n *\n * @example Warning::suppress(Warning::WARNING_NOT_A_TYPE) suppress a specific warning\n * @example Warning::suppress(true) suppresses all warnings\n * @example Warning::suppress(false) enables all warnings\n *\n * @api\n */\nstatic function suppress($suppress = true): void\n</code></pre> <pre><code>/**\n * Re-enable previously suppressed warning by id (has no effect when custom warning handler is set).\n *\n * @param bool|int $enable\n *\n * @example Warning::suppress(Warning::WARNING_NOT_A_TYPE) re-enables a specific warning\n * @example Warning::suppress(true) re-enables all warnings\n * @example Warning::suppress(false) suppresses all warnings\n *\n * @api\n */\nstatic function enable($enable = true): void\n</code></pre>"},{"location":"class-reference/#graphqlerrorclientaware","title":"GraphQL\\Error\\ClientAware","text":"<p>Implementing ClientAware allows graphql-php to decide if this error is safe to be shown to clients.</p> <p>Only errors that both implement this interface and return true from <code>isClientSafe()</code> will retain their original error message during formatting.</p> <p>All other errors will have their message replaced with \"Internal server error\".</p>"},{"location":"class-reference/#graphqlerrorclientaware-methods","title":"GraphQL\\Error\\ClientAware Methods","text":"<pre><code>/**\n * Is it safe to show the error message to clients?\n *\n * @api\n */\nfunction isClientSafe(): bool\n</code></pre>"},{"location":"class-reference/#graphqlerrordebugflag","title":"GraphQL\\Error\\DebugFlag","text":"<p>Collection of flags for error debugging.</p>"},{"location":"class-reference/#graphqlerrordebugflag-constants","title":"GraphQL\\Error\\DebugFlag Constants","text":"<pre><code>const NONE = 0;\nconst INCLUDE_DEBUG_MESSAGE = 1;\nconst INCLUDE_TRACE = 2;\nconst RETHROW_INTERNAL_EXCEPTIONS = 4;\nconst RETHROW_UNSAFE_EXCEPTIONS = 8;\n</code></pre>"},{"location":"class-reference/#graphqlerrorformattederror","title":"GraphQL\\Error\\FormattedError","text":"<p>This class is used for default error formatting. It converts PHP exceptions to spec-compliant errors and provides tools for error debugging.</p> <p>@see ExecutionResult</p> <p>@phpstan-import-type SerializableError from ExecutionResult @phpstan-import-type ErrorFormatter from ExecutionResult</p> <p>@see \\GraphQL\\Tests\\Error\\FormattedErrorTest</p>"},{"location":"class-reference/#graphqlerrorformattederror-methods","title":"GraphQL\\Error\\FormattedError Methods","text":"<pre><code>/**\n * Set default error message for internal errors formatted using createFormattedError().\n * This value can be overridden by passing 3rd argument to `createFormattedError()`.\n *\n * @api\n */\nstatic function setInternalErrorMessage(string $msg): void\n</code></pre> <pre><code>/**\n * Convert any exception to a GraphQL spec compliant array.\n *\n * This method only exposes the exception message when the given exception\n * implements the ClientAware interface, or when debug flags are passed.\n *\n * For a list of available debug flags @see \\GraphQL\\Error\\DebugFlag constants.\n *\n * @return SerializableError\n *\n * @api\n */\nstatic function createFromException(\n    Throwable $exception,\n    int $debugFlag = 'GraphQL\\\\Error\\\\DebugFlag::NONE',\n    ?string $internalErrorMessage = null\n): array\n</code></pre> <pre><code>/**\n * Returns error trace as serializable array.\n *\n * @return array&lt;int, array{\n *     file?: string,\n *     line?: int,\n *     function?: string,\n *     call?: string,\n * }&gt;\n *\n * @api\n */\nstatic function toSafeTrace(Throwable $error): array\n</code></pre>"},{"location":"class-reference/#graphqlserverstandardserver","title":"GraphQL\\Server\\StandardServer","text":"<p>GraphQL server compatible with both: express-graphql and Apollo Server. Usage Example:.</p> <pre><code>$server = new StandardServer([\n  'schema' =&gt; $mySchema\n]);\n$server-&gt;handleRequest();\n</code></pre> <p>Or using ServerConfig instance:</p> <pre><code>$config = GraphQL\\Server\\ServerConfig::create()\n    -&gt;setSchema($mySchema)\n    -&gt;setContext($myContext);\n\n$server = new GraphQL\\Server\\StandardServer($config);\n$server-&gt;handleRequest();\n</code></pre> <p>See dedicated section in docs for details.</p> <p>@see \\GraphQL\\Tests\\Server\\StandardServerTest</p>"},{"location":"class-reference/#graphqlserverstandardserver-methods","title":"GraphQL\\Server\\StandardServer Methods","text":"<pre><code>/**\n * @param ServerConfig|array&lt;string, mixed&gt; $config\n *\n * @api\n *\n * @throws InvariantViolation\n */\nfunction __construct($config)\n</code></pre> <pre><code>/**\n * Parses HTTP request, executes and emits response (using standard PHP `header` function and `echo`).\n *\n * When $parsedBody is not set, it uses PHP globals to parse a request.\n * It is possible to implement request parsing elsewhere (e.g. using framework Request instance)\n * and then pass it to the server.\n *\n * See `executeRequest()` if you prefer to emit the response yourself\n * (e.g. using the Response object of some framework).\n *\n * @param OperationParams|array&lt;OperationParams&gt; $parsedBody\n *\n * @api\n *\n * @throws \\Exception\n * @throws InvariantViolation\n * @throws RequestError\n */\nfunction handleRequest($parsedBody = null): void\n</code></pre> <pre><code>/**\n * Executes a GraphQL operation and returns an execution result\n * (or promise when promise adapter is different from SyncPromiseAdapter).\n *\n * When $parsedBody is not set, it uses PHP globals to parse a request.\n * It is possible to implement request parsing elsewhere (e.g. using framework Request instance)\n * and then pass it to the server.\n *\n * PSR-7 compatible method executePsrRequest() does exactly this.\n *\n * @param OperationParams|array&lt;OperationParams&gt; $parsedBody\n *\n * @throws \\Exception\n * @throws InvariantViolation\n * @throws RequestError\n *\n * @return ExecutionResult|array&lt;int, ExecutionResult&gt;|Promise\n *\n * @api\n */\nfunction executeRequest($parsedBody = null)\n</code></pre> <pre><code>/**\n * Executes PSR-7 request and fulfills PSR-7 response.\n *\n * See `executePsrRequest()` if you prefer to create response yourself\n * (e.g. using specific JsonResponse instance of some framework).\n *\n * @throws \\Exception\n * @throws \\InvalidArgumentException\n * @throws \\JsonException\n * @throws \\RuntimeException\n * @throws InvariantViolation\n * @throws RequestError\n *\n * @return ResponseInterface|Promise\n *\n * @api\n */\nfunction processPsrRequest(\n    Psr\\Http\\Message\\RequestInterface $request,\n    Psr\\Http\\Message\\ResponseInterface $response,\n    Psr\\Http\\Message\\StreamInterface $writableBodyStream\n)\n</code></pre> <pre><code>/**\n * Executes GraphQL operation and returns execution result\n * (or promise when promise adapter is different from SyncPromiseAdapter).\n *\n * @throws \\Exception\n * @throws \\JsonException\n * @throws InvariantViolation\n * @throws RequestError\n *\n * @return ExecutionResult|array&lt;int, ExecutionResult&gt;|Promise\n *\n * @api\n */\nfunction executePsrRequest(Psr\\Http\\Message\\RequestInterface $request)\n</code></pre>"},{"location":"class-reference/#graphqlserverserverconfig","title":"GraphQL\\Server\\ServerConfig","text":"<p>Server configuration class. Could be passed directly to server constructor. List of options accepted by create method is described in docs.</p> <p>Usage example:</p> <pre><code>$config = GraphQL\\Server\\ServerConfig::create()\n    -&gt;setSchema($mySchema)\n    -&gt;setContext($myContext);\n\n$server = new GraphQL\\Server\\StandardServer($config);\n</code></pre> <p>@see ExecutionResult</p> <p>@phpstan-type PersistedQueryLoader callable(string $queryId, OperationParams $operation): (string|DocumentNode) @phpstan-type RootValueResolver callable(OperationParams $operation, DocumentNode $doc, string $operationType): mixed @phpstan-type ValidationRulesOption array|null|callable(OperationParams $operation, DocumentNode $doc, string $operationType): array <p>@phpstan-import-type ErrorsHandler from ExecutionResult @phpstan-import-type ErrorFormatter from ExecutionResult</p> <p>@see \\GraphQL\\Tests\\Server\\ServerConfigTest</p>"},{"location":"class-reference/#graphqlserverserverconfig-methods","title":"GraphQL\\Server\\ServerConfig Methods","text":"<pre><code>/**\n * Converts an array of options to instance of ServerConfig\n * (or just returns empty config when array is not passed).\n *\n * @param array&lt;string, mixed&gt; $config\n *\n * @api\n *\n * @throws InvariantViolation\n */\nstatic function create(array $config = []): self\n</code></pre> <pre><code>/**\n * @param mixed|callable $context\n *\n * @api\n */\nfunction setContext($context): self\n</code></pre> <pre><code>/**\n * @param mixed|callable $rootValue\n *\n * @phpstan-param mixed|RootValueResolver $rootValue\n *\n * @api\n */\nfunction setRootValue($rootValue): self\n</code></pre> <pre><code>/**\n * @phpstan-param ErrorFormatter $errorFormatter\n *\n * @api\n */\nfunction setErrorFormatter(callable $errorFormatter): self\n</code></pre> <pre><code>/**\n * @phpstan-param ErrorsHandler $handler\n *\n * @api\n */\nfunction setErrorsHandler(callable $handler): self\n</code></pre> <pre><code>/**\n * Set validation rules for this server.\n *\n * @param array&lt;ValidationRule&gt;|callable|null $validationRules\n *\n * @phpstan-param ValidationRulesOption $validationRules\n *\n * @api\n */\nfunction setValidationRules($validationRules): self\n</code></pre> <pre><code>/**\n * @phpstan-param PersistedQueryLoader|null $persistedQueryLoader\n *\n * @api\n */\nfunction setPersistedQueryLoader(?callable $persistedQueryLoader): self\n</code></pre> <pre><code>/**\n * Set response debug flags.\n *\n * @see \\GraphQL\\Error\\DebugFlag class for a list of all available flags\n *\n * @api\n */\nfunction setDebugFlag(int $debugFlag = 'GraphQL\\\\Error\\\\DebugFlag::INCLUDE_DEBUG_MESSAGE'): self\n</code></pre> <pre><code>/**\n * Allow batching queries (disabled by default).\n *\n * @api\n */\nfunction setQueryBatching(bool $enableBatching): self\n</code></pre>"},{"location":"class-reference/#graphqlserverhelper","title":"GraphQL\\Server\\Helper","text":"<p>Contains functionality that could be re-used by various server implementations.</p> <p>@see \\GraphQL\\Tests\\Server\\HelperTest</p>"},{"location":"class-reference/#graphqlserverhelper-methods","title":"GraphQL\\Server\\Helper Methods","text":"<pre><code>/**\n * Parses HTTP request using PHP globals and returns GraphQL OperationParams\n * contained in this request. For batched requests it returns an array of OperationParams.\n *\n * This function does not check validity of these params\n * (validation is performed separately in validateOperationParams() method).\n *\n * If $readRawBodyFn argument is not provided - will attempt to read raw request body\n * from `php://input` stream.\n *\n * Internally it normalizes input to $method, $bodyParams and $queryParams and\n * calls `parseRequestParams()` to produce actual return value.\n *\n * For PSR-7 request parsing use `parsePsrRequest()` instead.\n *\n * @throws RequestError\n *\n * @return OperationParams|array&lt;int, OperationParams&gt;\n *\n * @api\n */\nfunction parseHttpRequest(?callable $readRawBodyFn = null)\n</code></pre> <pre><code>/**\n * Parses normalized request params and returns instance of OperationParams\n * or array of OperationParams in case of batch operation.\n *\n * Returned value is a suitable input for `executeOperation` or `executeBatch` (if array)\n *\n * @param array&lt;mixed&gt; $bodyParams\n * @param array&lt;mixed&gt; $queryParams\n *\n * @throws RequestError\n *\n * @return OperationParams|array&lt;int, OperationParams&gt;\n *\n * @api\n */\nfunction parseRequestParams(string $method, array $bodyParams, array $queryParams)\n</code></pre> <pre><code>/**\n * Checks validity of OperationParams extracted from HTTP request and returns an array of errors\n * if params are invalid (or empty array when params are valid).\n *\n * @return list&lt;RequestError&gt;\n *\n * @api\n */\nfunction validateOperationParams(GraphQL\\Server\\OperationParams $params): array\n</code></pre> <pre><code>/**\n * Executes GraphQL operation with given server configuration and returns execution result\n * (or promise when promise adapter is different from SyncPromiseAdapter).\n *\n * @throws \\Exception\n * @throws InvariantViolation\n *\n * @return ExecutionResult|Promise\n *\n * @api\n */\nfunction executeOperation(GraphQL\\Server\\ServerConfig $config, GraphQL\\Server\\OperationParams $op)\n</code></pre> <pre><code>/**\n * Executes batched GraphQL operations with shared promise queue\n * (thus, effectively batching deferreds|promises of all queries at once).\n *\n * @param array&lt;OperationParams&gt; $operations\n *\n * @throws \\Exception\n * @throws InvariantViolation\n *\n * @return array&lt;int, ExecutionResult&gt;|Promise\n *\n * @api\n */\nfunction executeBatch(GraphQL\\Server\\ServerConfig $config, array $operations)\n</code></pre> <pre><code>/**\n * Send response using standard PHP `header()` and `echo`.\n *\n * @param Promise|ExecutionResult|array&lt;ExecutionResult&gt; $result\n *\n * @api\n *\n * @throws \\JsonException\n */\nfunction sendResponse($result): void\n</code></pre> <pre><code>/**\n * Converts PSR-7 request to OperationParams or an array thereof.\n *\n * @throws RequestError\n *\n * @return OperationParams|array&lt;OperationParams&gt;\n *\n * @api\n */\nfunction parsePsrRequest(Psr\\Http\\Message\\RequestInterface $request)\n</code></pre> <pre><code>/**\n * Converts query execution result to PSR-7 response.\n *\n * @param Promise|ExecutionResult|array&lt;ExecutionResult&gt; $result\n *\n * @throws \\InvalidArgumentException\n * @throws \\JsonException\n * @throws \\RuntimeException\n *\n * @return Promise|ResponseInterface\n *\n * @api\n */\nfunction toPsrResponse(\n    $result,\n    Psr\\Http\\Message\\ResponseInterface $response,\n    Psr\\Http\\Message\\StreamInterface $writableBodyStream\n)\n</code></pre>"},{"location":"class-reference/#graphqlserveroperationparams","title":"GraphQL\\Server\\OperationParams","text":"<p>Structure representing parsed HTTP parameters for GraphQL operation.</p> <p>The properties in this class are not strictly typed, as this class is only meant to serve as an intermediary representation which is not yet validated.</p>"},{"location":"class-reference/#graphqlserveroperationparams-props","title":"GraphQL\\Server\\OperationParams Props","text":"<pre><code>/**\n * Id of the query (when using persisted queries).\n *\n * Valid aliases (case-insensitive):\n * - id\n * - queryId\n * - documentId\n *\n * @api\n *\n * @var mixed should be string|null\n */\npublic $queryId;\n\n/**\n * A document containing GraphQL operations and fragments to execute.\n *\n * @api\n *\n * @var mixed should be string|null\n */\npublic $query;\n\n/**\n * The name of the operation in the document to execute.\n *\n * @api\n *\n * @var mixed should be string|null\n */\npublic $operation;\n\n/**\n * Values for any variables defined by the operation.\n *\n * @api\n *\n * @var mixed should be array&lt;string, mixed&gt;\n */\npublic $variables;\n\n/**\n * Reserved for implementors to extend the protocol however they see fit.\n *\n * @api\n *\n * @var mixed should be array&lt;string, mixed&gt;\n */\npublic $extensions;\n\n/**\n * Executed in read-only context (e.g. via HTTP GET request)?\n *\n * @api\n */\npublic $readOnly;\n\n/**\n * The raw params used to construct this instance.\n *\n * @api\n *\n * @var array&lt;string, mixed&gt;\n */\npublic $originalInput;\n</code></pre>"},{"location":"class-reference/#graphqlserveroperationparams-methods","title":"GraphQL\\Server\\OperationParams Methods","text":"<pre><code>/**\n * Creates an instance from given array.\n *\n * @param array&lt;string, mixed&gt; $params\n *\n * @api\n */\nstatic function create(array $params, bool $readonly = false): GraphQL\\Server\\OperationParams\n</code></pre>"},{"location":"class-reference/#graphqlutilsbuildschema","title":"GraphQL\\Utils\\BuildSchema","text":"<p>Build instance of @see \\GraphQL\\Type\\Schema out of schema language definition (string or parsed AST).</p> <p>See schema definition language docs for details.</p> <p>@phpstan-import-type TypeConfigDecorator from ASTDefinitionBuilder @phpstan-import-type FieldConfigDecorator from ASTDefinitionBuilder</p> <p>@phpstan-type BuildSchemaOptions array{ assumeValid?: bool, assumeValidSDL?: bool }</p> <ul> <li>assumeValid:   When building a schema from a GraphQL service's introspection result, it   might be safe to assume the schema is valid. Set to true to assume the   produced schema is valid.</li> </ul> <p>Default: false</p> <ul> <li>assumeValidSDL:   Set to true to assume the SDL is valid.</li> </ul> <p>Default: false</p> <p>@see \\GraphQL\\Tests\\Utils\\BuildSchemaTest</p>"},{"location":"class-reference/#graphqlutilsbuildschema-methods","title":"GraphQL\\Utils\\BuildSchema Methods","text":"<pre><code>/**\n * A helper function to build a GraphQLSchema directly from a source\n * document.\n *\n * @param DocumentNode|Source|string $source\n * @param array&lt;string, bool&gt; $options\n *\n * @phpstan-param TypeConfigDecorator|null $typeConfigDecorator\n * @phpstan-param FieldConfigDecorator|null $fieldConfigDecorator\n * @phpstan-param BuildSchemaOptions $options\n *\n * @api\n *\n * @throws \\Exception\n * @throws \\ReflectionException\n * @throws Error\n * @throws InvariantViolation\n * @throws SyntaxError\n */\nstatic function build(\n    $source,\n    ?callable $typeConfigDecorator = null,\n    array $options = [],\n    ?callable $fieldConfigDecorator = null\n): GraphQL\\Type\\Schema\n</code></pre> <pre><code>/**\n * This takes the AST of a schema from @see \\GraphQL\\Language\\Parser::parse().\n *\n * If no schema definition is provided, then it will look for types named Query and Mutation.\n *\n * Given that AST it constructs a @see \\GraphQL\\Type\\Schema. The resulting schema\n * has no resolve methods, so execution will use default resolvers.\n *\n * @param array&lt;string, bool&gt; $options\n *\n * @phpstan-param TypeConfigDecorator|null $typeConfigDecorator\n * @phpstan-param FieldConfigDecorator|null $fieldConfigDecorator\n * @phpstan-param BuildSchemaOptions $options\n *\n * @api\n *\n * @throws \\Exception\n * @throws \\ReflectionException\n * @throws Error\n * @throws InvariantViolation\n */\nstatic function buildAST(\n    GraphQL\\Language\\AST\\DocumentNode $ast,\n    ?callable $typeConfigDecorator = null,\n    array $options = [],\n    ?callable $fieldConfigDecorator = null\n): GraphQL\\Type\\Schema\n</code></pre>"},{"location":"class-reference/#graphqlutilsast","title":"GraphQL\\Utils\\AST","text":"<p>Various utilities dealing with AST.</p>"},{"location":"class-reference/#graphqlutilsast-methods","title":"GraphQL\\Utils\\AST Methods","text":"<pre><code>/**\n * Convert representation of AST as an associative array to instance of GraphQL\\Language\\AST\\Node.\n *\n * For example:\n *\n * ```php\n * AST::fromArray([\n *     'kind' =&gt; 'ListValue',\n *     'values' =&gt; [\n *         ['kind' =&gt; 'StringValue', 'value' =&gt; 'my str'],\n *         ['kind' =&gt; 'StringValue', 'value' =&gt; 'my other str']\n *     ],\n *     'loc' =&gt; ['start' =&gt; 21, 'end' =&gt; 25]\n * ]);\n * ```\n *\n * Will produce instance of `ListValueNode` where `values` prop is a lazily-evaluated `NodeList`\n * returning instances of `StringValueNode` on access.\n *\n * This is a reverse operation for AST::toArray($node)\n *\n * @param array&lt;string, mixed&gt; $node\n *\n * @api\n *\n * @throws \\JsonException\n * @throws InvariantViolation\n */\nstatic function fromArray(array $node): GraphQL\\Language\\AST\\Node\n</code></pre> <pre><code>/**\n * Convert AST node to serializable array.\n *\n * @return array&lt;string, mixed&gt;\n *\n * @api\n */\nstatic function toArray(GraphQL\\Language\\AST\\Node $node): array\n</code></pre> <pre><code>/**\n * Produces a GraphQL Value AST given a PHP value.\n *\n * Optionally, a GraphQL type may be provided, which will be used to\n * disambiguate between value primitives.\n *\n * | PHP Value     | GraphQL Value        |\n * | ------------- | -------------------- |\n * | Object        | Input Object         |\n * | Assoc Array   | Input Object         |\n * | Array         | List                 |\n * | Boolean       | Boolean              |\n * | String        | String / Enum Value  |\n * | Int           | Int                  |\n * | Float         | Int / Float          |\n * | Mixed         | Enum Value           |\n * | null          | NullValue            |\n *\n * @param mixed $value\n * @param InputType&amp;Type $type\n *\n * @throws \\JsonException\n * @throws InvariantViolation\n * @throws SerializationError\n *\n * @return (ValueNode&amp;Node)|null\n *\n * @api\n */\nstatic function astFromValue($value, GraphQL\\Type\\Definition\\InputType $type): ?GraphQL\\Language\\AST\\ValueNode\n</code></pre> <pre><code>/**\n * Produces a PHP value given a GraphQL Value AST.\n *\n * A GraphQL type must be provided, which will be used to interpret different\n * GraphQL Value literals.\n *\n * Returns `null` when the value could not be validly coerced according to\n * the provided type.\n *\n * | GraphQL Value        | PHP Value     |\n * | -------------------- | ------------- |\n * | Input Object         | Assoc Array   |\n * | List                 | Array         |\n * | Boolean              | Boolean       |\n * | String               | String        |\n * | Int / Float          | Int / Float   |\n * | Enum Value           | Mixed         |\n * | Null Value           | null          |\n *\n * @param (ValueNode&amp;Node)|null $valueNode\n * @param array&lt;string, mixed&gt;|null $variables\n *\n * @throws \\Exception\n *\n * @return mixed\n *\n * @api\n */\nstatic function valueFromAST(\n    ?GraphQL\\Language\\AST\\ValueNode $valueNode,\n    GraphQL\\Type\\Definition\\Type $type,\n    ?array $variables = null\n)\n</code></pre> <pre><code>/**\n * Produces a PHP value given a GraphQL Value AST.\n *\n * Unlike `valueFromAST()`, no type is provided. The resulting PHP value\n * will reflect the provided GraphQL value AST.\n *\n * | GraphQL Value        | PHP Value     |\n * | -------------------- | ------------- |\n * | Input Object         | Assoc Array   |\n * | List                 | Array         |\n * | Boolean              | Boolean       |\n * | String               | String        |\n * | Int / Float          | Int / Float   |\n * | Enum                 | Mixed         |\n * | Null                 | null          |\n *\n * @param array&lt;string, mixed&gt;|null $variables\n *\n * @throws \\Exception\n *\n * @return mixed\n *\n * @api\n */\nstatic function valueFromASTUntyped(GraphQL\\Language\\AST\\Node $valueNode, ?array $variables = null)\n</code></pre> <pre><code>/**\n * Returns type definition for given AST Type node.\n *\n * @param callable(string): ?Type $typeLoader\n * @param NamedTypeNode|ListTypeNode|NonNullTypeNode $inputTypeNode\n *\n * @throws \\Exception\n *\n * @api\n */\nstatic function typeFromAST(callable $typeLoader, GraphQL\\Language\\AST\\Node $inputTypeNode): ?GraphQL\\Type\\Definition\\Type\n</code></pre> <pre><code>/**\n * Returns the operation within a document by name.\n *\n * If a name is not provided, an operation is only returned if the document has exactly one.\n *\n * @api\n */\nstatic function getOperationAST(GraphQL\\Language\\AST\\DocumentNode $document, ?string $operationName = null): ?GraphQL\\Language\\AST\\OperationDefinitionNode\n</code></pre> <pre><code>/**\n * Provided a collection of ASTs, presumably each from different files,\n * concatenate the ASTs together into batched AST, useful for validating many\n * GraphQL source files which together represent one conceptual application.\n *\n * @param array&lt;DocumentNode&gt; $documents\n *\n * @api\n */\nstatic function concatAST(array $documents): GraphQL\\Language\\AST\\DocumentNode\n</code></pre>"},{"location":"class-reference/#graphqlutilsschemaprinter","title":"GraphQL\\Utils\\SchemaPrinter","text":"<p>Prints the contents of a Schema in schema definition language.</p> <p>All sorting options sort alphabetically. If not given or <code>false</code>, the original schema definition order will be used.</p> <p>@phpstan-type Options array{ sortArguments?: bool, sortEnumValues?: bool, sortFields?: bool, sortInputFields?: bool, sortTypes?: bool, }</p> <p>@see \\GraphQL\\Tests\\Utils\\SchemaPrinterTest</p>"},{"location":"class-reference/#graphqlutilsschemaprinter-methods","title":"GraphQL\\Utils\\SchemaPrinter Methods","text":"<pre><code>/**\n * @param array&lt;string, bool&gt; $options\n *\n * @phpstan-param Options $options\n *\n * @api\n *\n * @throws \\JsonException\n * @throws Error\n * @throws InvariantViolation\n * @throws SerializationError\n */\nstatic function doPrint(GraphQL\\Type\\Schema $schema, array $options = []): string\n</code></pre> <pre><code>/**\n * @param array&lt;string, bool&gt; $options\n *\n * @phpstan-param Options $options\n *\n * @api\n *\n * @throws \\JsonException\n * @throws Error\n * @throws InvariantViolation\n * @throws SerializationError\n */\nstatic function printIntrospectionSchema(GraphQL\\Type\\Schema $schema, array $options = []): string\n</code></pre>"},{"location":"complementary-tools/","title":"Complementary Tools","text":""},{"location":"complementary-tools/#server-integrations","title":"Server Integrations","text":"<ul> <li>Standard Server \u2013 Out of the box integration with any PSR-7 compatible framework (like Slim or Laminas Mezzio)</li> <li>Lighthouse \u2013 Laravel package, SDL-first</li> <li>Laravel GraphQL - Laravel package, code-first</li> <li>OverblogGraphQLBundle \u2013 Symfony bundle</li> <li>WP-GraphQL - WordPress plugin</li> <li>Siler - Flat files and plain-old PHP functions, supports Swoole</li> <li>API Platform - Creates a GraphQL API from PHP models</li> <li>LDOG Stack - Laravel, Doctrine ORM, and GraphQL application template</li> </ul>"},{"location":"complementary-tools/#server-utilities","title":"Server Utilities","text":"<ul> <li>GraphQLite \u2013 Use PHP Annotations to define your schema</li> <li>GraphQL Doctrine \u2013 Define types with Doctrine ORM annotations</li> <li>GraphQL Type Driver for Doctrine ORM \u2013 Includes events, pagination with the Complete Connection Model, and support for all default Doctrine Types</li> <li>DataLoaderPHP \u2013 Implements deferred resolvers</li> <li>GraphQL Upload \u2013 PSR-15 middleware to support file uploads in GraphQL</li> <li>GraphQL Batch Processor \u2013 Provides a builder interface for defining collection, querying, filtering, and post-processing logic of batched data fetches</li> <li>GraphQL Utils \u2013 Objective schema definition builders (no need for arrays anymore)</li> <li>Relay Library \u2013 Helps construct Relay related schema definitions</li> <li>Resonance/GraphQL \u2013 Integrates with Swoole for parallelism. Define your schema code-first with annotations.</li> <li>GraphQL PHP Validation Toolkit - Small library for validation of user input</li> <li>MLL Scalars - Collection of custom scalar types</li> <li>X GraphQL - Provides set of libraries for building http schema, schema gateway, transforming schema, generating PHP code from execution definition, and more.</li> <li>GraphQL Attribute Schema - Build your GraphQL schema for webonyx/graphql-php using PHP attributes instead of array-based configuration</li> </ul>"},{"location":"complementary-tools/#graphql-clients","title":"GraphQL Clients","text":"<ul> <li>GraphiQL \u2013 Graphical interactive in-browser GraphQL IDE</li> <li>GraphQL Playground \u2013 GraphQL IDE for better development workflows (GraphQL Subscriptions, interactive docs &amp; collaboration)</li> <li>Altair GraphQL Client - Beautiful feature-rich GraphQL Client for all platforms</li> <li>Sailor - Typesafe GraphQL client for PHP</li> </ul>"},{"location":"concepts/","title":"Concepts","text":""},{"location":"concepts/#overview","title":"Overview","text":"<p>GraphQL is data-centric. On the very top level it is built around three major concepts: Schema, Query and Mutation.</p> <p>You are expected to express your application as a Schema (aka Type System) and expose it as a single HTTP endpoint (e.g. using our standard server). Application clients (e.g. web or mobile clients) send Queries to this endpoint to request structured data and Mutations to perform changes (usually with HTTP POST method).</p>"},{"location":"concepts/#queries","title":"Queries","text":"<p>Queries are expressed in simple language that resembles JSON:</p> <pre><code>{\n  hero {\n    name\n    friends {\n      name\n    }\n  }\n}\n</code></pre> <p>It was designed to mirror the structure of the expected response:</p> <pre><code>{\n\"hero\": {\n\"name\": \"R2-D2\",\n\"friends\": [\n{ \"name\": \"Luke Skywalker\" },\n{ \"name\": \"Han Solo\" },\n{ \"name\": \"Leia Organa\" }\n]\n}\n}\n</code></pre> <p>The graphql-php runtime parses Queries, makes sure that they are valid for a given Type System and executes using data fetching tools provided by you as part of the integration. Queries are supposed to be idempotent.</p>"},{"location":"concepts/#mutations","title":"Mutations","text":"<p>Mutations are root fields that are allowed to have side effects, such as creating, updating or deleting data. In contrast to Query fields, the fields within the root Mutation type are executed serially. Otherwise, their definition and execution is identical to all other fields.</p> <pre><code>mutation CreateReviewForEpisode($ep: Episode!, $review: ReviewInput!) {\n  createReview(episode: $ep, review: $review) {\n    stars\n    commentary\n  }\n}\n</code></pre> <p>Variables <code>$ep</code> and <code>$review</code> are sent alongside with the mutation. A full HTTP request might look like this:</p> <pre><code>// POST /graphql-endpoint\n// Content-Type: application/javascript\n//\n{\n\"query\": \"mutation CreateReviewForEpisode...\",\n\"variables\": {\n\"ep\": \"JEDI\",\n\"review\": {\n\"stars\": 5,\n\"commentary\": \"This is a great movie!\"\n}\n}\n}\n</code></pre> <p>As you see variables may include complex objects and they will be correctly validated by the graphql-php runtime.</p> <p>Another nice feature of GraphQL mutations is that they also hold the query for data to be returned after mutation. In our example the mutation will return:</p> <pre><code>{\n  \"createReview\": {\n    \"stars\": 5,\n    \"commentary\": \"This is a great movie!\"\n  }\n}\n</code></pre>"},{"location":"concepts/#type-system","title":"Type System","text":"<p>Conceptually a GraphQL type is a collection of fields. Each field in turn has its own type which allows building complex hierarchies.</p> <p>Quick example on pseudo-language:</p> <pre><code>type BlogPost {\n    title: String!\n    author: User\n    body: String\n}\n\ntype User {\n    id: Id!\n    firstName: String\n    lastName: String\n}\n</code></pre> <p>The type system is at the heart of GraphQL integration. That's where graphql-php comes into play.</p> <p>It provides the following tools and primitives to describe your App as a hierarchy of types:</p> <ul> <li>Primitives for defining objects and interfaces</li> <li>Primitives for defining enumerations and unions</li> <li>Primitives for defining custom scalar types</li> <li>Built-in scalar types: <code>ID</code>, <code>String</code>, <code>Int</code>, <code>Float</code>, <code>Boolean</code></li> <li>Built-in type modifiers: <code>ListOf</code> and <code>NonNull</code></li> </ul> <p>Same example expressed in graphql-php:</p> <pre><code>use GraphQL\\Type\\Definition\\Type;\nuse GraphQL\\Type\\Definition\\ObjectType;\n\n$userType = new ObjectType([\n    'name' =&gt; 'User',\n    'fields' =&gt; [\n        'id' =&gt; Type::nonNull(Type::id()),\n        'firstName' =&gt; Type::string(),\n        'lastName' =&gt; Type::string()\n    ]\n]);\n\n$blogPostType = new ObjectType([\n    'name' =&gt; 'BlogPost',\n    'fields' =&gt; [\n        'title' =&gt; Type::nonNull(Type::string()),\n        'author' =&gt; $userType\n    ]\n]);\n</code></pre>"},{"location":"concepts/#further-reading","title":"Further Reading","text":"<p>To get deeper understanding of GraphQL concepts - read the docs on official GraphQL website</p> <p>To get started with graphql-php - continue to next section \"Getting Started\"</p>"},{"location":"data-fetching/","title":"Fetching Data","text":""},{"location":"data-fetching/#overview","title":"Overview","text":"<p>GraphQL is data-storage agnostic. You can use any underlying data storage engine, including but not limited to SQL or NoSQL databases, plain files or in-memory data structures.</p> <p>In order to convert the GraphQL query to a PHP array, graphql-php traverses query fields (using depth-first algorithm) and runs the special resolve function on each field. This resolve function is provided by you as a part of the field definition or query execution call.</p> <p>The result returned by the resolve function is directly included in the response (for scalars and enums) or passed down to nested fields (for objects).</p> <p>Let's walk through an example. Consider the following GraphQL query:</p> <pre><code>{\n  lastStory {\n    title\n    author {\n      name\n    }\n  }\n}\n</code></pre> <p>We need a <code>Schema</code> that can fulfill it. On the very top level, the <code>Schema</code> contains the <code>Query</code> type:</p> <pre><code>use GraphQL\\Type\\Definition\\ObjectType;\n\n$queryType = new ObjectType([\n    'name' =&gt; 'Query',\n        'fields' =&gt; [\n        'lastStory' =&gt; [\n            'type' =&gt; $blogStoryType,\n            'resolve' =&gt; fn (): array =&gt; [\n                'id' =&gt; 1,\n                'title' =&gt; 'Example blog post',\n                'authorId' =&gt; 1\n            ],\n        ]\n    ]\n]);\n</code></pre> <p>As we see, the field lastStory has a resolve function that is responsible for fetching data.</p> <p>In our example, we simply return a static value, but in the real-world application you would query your data source and return the result from there.</p> <p>Since lastStory is of composite type BlogStory, this result is passed down to fields of this type:</p> <pre><code>use GraphQL\\Type\\Definition\\Type;\nuse GraphQL\\Type\\Definition\\ObjectType;\n\nconst USERS = [\n    1 =&gt; [\n        'id' =&gt; 1,\n        'name' =&gt; 'Smith'\n    ],\n    2 =&gt; [\n        'id' =&gt; 2,\n        'name' =&gt; 'Anderson'\n    ]\n];\n\n$blogStoryType = new ObjectType([\n    'name' =&gt; 'BlogStory',\n    'fields' =&gt; [\n        'author' =&gt; [\n            'type' =&gt; $userType,\n            'resolve' =&gt; fn (array $blogStory): array =&gt; USERS[$blogStory['authorId']],\n        ],\n        'title' =&gt; [\n            'type' =&gt; Type::string()\n        ]\n    ]\n]);\n</code></pre> <p>Here $blogStory is the array returned by the lastStory field above.</p> <p>Again: in real-world applications you would fetch user data from your data source by authorId and return it. Also, note that you don't have to return arrays. You can return any value, graphql-php will pass it untouched to nested resolvers.</p> <p>But then the question appears - the field title has no resolve option, how is it resolved? When you define no custom resolver, the default field resolver applies.</p>"},{"location":"data-fetching/#default-field-resolver","title":"Default Field Resolver","text":"<p>graphql-php provides the following default field resolver:</p> <pre><code>use GraphQL\\Type\\Definition\\ResolveInfo;\n\nfunction defaultFieldResolver($objectValue, array $args, $context, ResolveInfo $info)\n{\n    $fieldName = $info-&gt;fieldName;\n    $property = null;\n\n    if (is_array($objectValue) || $objectValue instanceof ArrayAccess) {\n        if (isset($objectValue[$fieldName])) {\n            $property = $objectValue[$fieldName];\n        }\n    } elseif (is_object($objectValue)) {\n        if (isset($objectValue-&gt;{$fieldName})) {\n            $property = $objectValue-&gt;{$fieldName};\n        }\n    }\n\n    return $property instanceof Closure\n        ? $property($objectValue, $args, $contextValue, $info)\n        : $property;\n}\n</code></pre> <p>It returns value by key (for arrays) or property (for objects). If the value is not set, it returns null.</p> <p>To override the default resolver, pass it as an argument to executeQuery.</p>"},{"location":"data-fetching/#default-field-resolver-per-type","title":"Default Field Resolver per Type","text":"<p>Sometimes it might be convenient to set a default field resolver per type. You can do so by providing the resolveField option in the type config. For example:</p> <pre><code>use GraphQL\\Type\\Definition\\Type;\nuse GraphQL\\Type\\Definition\\ObjectType;\nuse GraphQL\\Type\\Definition\\ResolveInfo;\n\n$userType = new ObjectType([\n    'name' =&gt; 'User',\n    'fields' =&gt; [\n        'name' =&gt; Type::string(),\n        'email' =&gt; Type::string()\n    ],\n    'resolveField' =&gt; function (User $user, array $args, $context, ResolveInfo $info): ?string {\n        switch ($info-&gt;fieldName) {\n            case 'name': return $user-&gt;getName();\n            case 'email': return $user-&gt;getEmail();\n            default: return null;\n        }\n    },\n]);\n</code></pre> <p>Keep in mind that field resolver has precedence over default field resolver per type which in turn has precedence over default field resolver.</p>"},{"location":"data-fetching/#optimize-resolvers","title":"Optimize Resolvers","text":"<p>The 4th argument of resolver functions is an instance of ResolveInfo. It contains information that is useful for the field resolution process.</p> <p>Depending on which data source is used, knowing which fields the client queried can be used to optimize the performance of a resolver. For example, an SQL query may only need to select the queried fields.</p> <p>The following example limits which columns are selected from the database:</p> <pre><code>use GraphQL\\Type\\Definition\\ObjectType;\nuse GraphQL\\Type\\Definition\\ResolveInfo;\n\n$queryType = new ObjectType([\n    'name' =&gt; 'Query',\n    'fields' =&gt; [\n        'lastStory' =&gt; [\n            'type' =&gt; $storyType,\n            'resolve' =&gt; function ($root, array $args, $context, ResolveInfo $resolveInfo): Story {\n                // Fictitious API, use whatever database access your application/framework provides\n                $builder = Story::builder();\n                foreach ($resolveInfo-&gt;getFieldSelection() as $field =&gt; $_) {\n                    $builder-&gt;addSelect($field);\n                }\n\n                return $builder-&gt;last();\n            }\n        ]\n    ]\n]);\n</code></pre>"},{"location":"data-fetching/#solving-n1-problem","title":"Solving N+1 Problem","text":"<p>Since: 0.9.0</p> <p>One of the most annoying problems with data fetching is a so-called N+1 problem.  Consider following GraphQL query:</p> <pre><code>{\n  topStories(limit: 10) {\n    title\n    author {\n      name\n      email\n    }\n  }\n}\n</code></pre> <p>Naive field resolution process would require up to 10 calls to the underlying data store to fetch authors for all 10 stories.</p> <p>graphql-php provides tools to mitigate this problem: it allows you to defer actual field resolution to a later stage when one batched query could be executed instead of 10 distinct queries.</p> <p>Here is an example of BlogStory resolver for field author that uses deferring:</p> <pre><code>use GraphQL\\Deferred;\n\n'resolve' =&gt; function (array $blogStory): Deferred {\n    MyUserBuffer::add($blogStory['authorId']);\n\n    return new Deferred(function () use ($blogStory): User {\n        MyUserBuffer::loadBuffered();\n\n        return MyUserBuffer::get($blogStory['authorId']);\n    });\n}\n</code></pre> <p>In this example, we fill up the buffer with 10 author ids first. Then graphql-php continues resolving other non-deferred fields until there are none of them left.</p> <p>After that, it calls closures wrapped by <code>GraphQL\\Deferred</code> which in turn load all buffered ids once (using SQL <code>IN(?)</code>, Redis <code>MGET</code> or similar tools) and returns the final field value.</p> <p>Originally this approach was advocated by Facebook in their Dataloader project. This solution enables very interesting optimizations at no cost. Consider the following query:</p> <pre><code>{\n  topStories(limit: 10) {\n    author {\n      email\n    }\n  }\n  category {\n    stories(limit: 10) {\n      author {\n        email\n      }\n    }\n  }\n}\n</code></pre> <p>Even though author field is located on different levels of the query - it can be buffered in the same buffer. In this example, only one query will be executed for all story authors comparing to 20 queries in a naive implementation.</p>"},{"location":"data-fetching/#async-php","title":"Async PHP","text":"<p>If your project runs in an environment that supports async operations (like HHVM, ReactPHP, AMPHP, appserver.io, PHP threads, etc) you can leverage the power of your platform to resolve some fields asynchronously.</p> <p>The only requirement: your platform must support the concept of Promises compatible with Promises A+ specification.</p> <p>To start using this feature, switch facade method for query execution from executeQuery to promiseToExecute:</p> <pre><code>use GraphQL\\GraphQL;\nuse GraphQL\\Executor\\ExecutionResult;\n\n$promise = GraphQL::promiseToExecute(\n    $promiseAdapter,\n    $schema,\n    $queryString,\n    $rootValue = null,\n    $contextValue = null,\n    $variableValues = null,\n    $operationName = null,\n    $fieldResolver = null,\n    $validationRules = null\n);\n$promise-&gt;then(fn (ExecutionResult $result): array =&gt; $result-&gt;toArray());\n</code></pre> <p>Where $promiseAdapter is an instance of:</p> <ul> <li> <p>For ReactPHP (requires react/promise as composer dependency):  <code>GraphQL\\Executor\\Promise\\Adapter\\ReactPromiseAdapter</code></p> </li> <li> <p>For AMPHP:  <code>GraphQL\\Executor\\Promise\\Adapter\\AmpPromiseAdapter</code></p> </li> <li> <p>For Swoole or OpenSwoole:    You can use an external library: Resonance</p> </li> <li> <p>Other platforms: write your own class implementing interface:  <code>GraphQL\\Executor\\Promise\\PromiseAdapter</code>.</p> </li> </ul> <p>Then your resolve functions should return promises of your platform instead of <code>GraphQL\\Deferred</code>s.</p>"},{"location":"error-handling/","title":"Handling Errors","text":""},{"location":"error-handling/#errors-in-graphql","title":"Errors in GraphQL","text":"<p>There are 3 types of errors in GraphQL:</p> <ul> <li>Syntax: query has invalid syntax and could not be parsed;</li> <li>Validation: query is incompatible with type system (e.g. unknown field is requested);</li> <li>Execution: occurs when some field resolver throws (or returns unexpected value).</li> </ul> <p>When Syntax or Validation errors are detected, an exception is thrown and the query is not executed.</p> <p>Exceptions thrown during query execution are caught and collected in the result. They are available in $errors prop of <code>GraphQL\\Executor\\ExecutionResult</code>.</p> <p>GraphQL is forgiving to Execution errors which occur in resolvers of nullable fields. If such field throws or returns unexpected value the value of the field in response will be simply replaced with null and error entry will be registered.</p> <p>If an exception is thrown in the non-null field - error bubbles up to the first nullable field. This nullable field is replaced with null and error entry is added to the result. If all fields up to the root are non-null - data entry will be removed from the result and only errors key will be presented.</p> <p>When the result is converted to a serializable array using its toArray() method, all errors are converted to arrays as well using default error formatting (see below).</p> <p>Alternatively, you can apply custom error filtering and formatting for your specific requirements.</p>"},{"location":"error-handling/#default-error-formatting","title":"Default Error formatting","text":"<p>By default, each error entry is converted to an associative array with following structure:</p> <pre><code>[\n    'message' =&gt; 'Error message',\n    'extensions' =&gt; [\n        'key' =&gt; 'value',\n    ],\n    'locations' =&gt; [\n        ['line' =&gt; 1, 'column' =&gt; 2],\n    ],\n    'path' =&gt; [\n        'listField',\n        0,\n        'fieldWithException',\n    ],\n];\n</code></pre> <p>Entry at key locations points to a character in query string which caused the error. In some cases (like deep fragment fields) locations will include several entries to track down the path to field with the error in query.</p> <p>Entry at key path exists only for errors caused by exceptions thrown in resolvers. It contains a path from the very root field to actual field value producing an error (including indexes for list types and field names for composite types).</p>"},{"location":"error-handling/#internal-errors","title":"Internal errors","text":"<p>As of version 0.10.0, all exceptions thrown in resolvers are reported with generic message \"Internal server error\". This is done to avoid information leak in production environments (e.g. database connection errors, file access errors, etc).</p> <p>Only exceptions implementing interface <code>GraphQL\\Error\\ClientAware</code> and claiming themselves as safe will be reported with a full error message.</p> <p>For example:</p> <pre><code>use GraphQL\\Error\\ClientAware;\n\nclass MySafeException extends \\Exception implements ClientAware\n{\n    public function isClientSafe(): bool\n    {\n        return true;\n    }\n}\n</code></pre> <p>When such exception is thrown it will be reported with a full error message:</p> <pre><code>[\n    'message' =&gt; 'My reported error',\n    'locations' =&gt; [\n        ['line' =&gt; 10, 'column' =&gt; 2],\n    ],\n    'path' =&gt; [\n        'path',\n        'to',\n        'fieldWithException',\n    ]\n];\n</code></pre> <p>To change default \"Internal server error\" message to something else, use:</p> <pre><code>GraphQL\\Error\\FormattedError::setInternalErrorMessage(\"Unexpected error\");\n</code></pre>"},{"location":"error-handling/#debugging-tools","title":"Debugging tools","text":"<p>During development or debugging, use <code>DebugFlag::INCLUDE_DEBUG_MESSAGE</code> to add hidden error messages each formatted error entry under the key <code>extensions.debugMessage</code>.</p> <pre><code>use GraphQL\\GraphQL;\nuse GraphQL\\Error\\DebugFlag;\n\n$result = GraphQL::executeQuery(/*args*/)\n    -&gt;toArray(DebugFlag::INCLUDE_DEBUG_MESSAGE);\n</code></pre> <p>If you also want to add the exception trace, pass <code>DebugFlag::INCLUDE_DEBUG_MESSAGE | DebugFlag::INCLUDE_TRACE</code> instead. This will make each error entry look like this:</p> <pre><code>[\n    'message' =&gt; 'Internal server error',\n    'locations' =&gt; [\n        ['line' =&gt; 10, 'column' =&gt; 2],\n    ],\n    'path' =&gt; [\n        'listField',\n        0,\n        'fieldWithException',\n    ],\n    'extensions' =&gt; [\n        'debugMessage' =&gt; 'Actual exception message',\n        'trace' =&gt; [\n            // Formatted original exception trace\n        ],\n    ],\n]\n</code></pre> <p>If you prefer the first resolver exception to be re-thrown, use the following flags:</p> <pre><code>use GraphQL\\GraphQL;\nuse GraphQL\\Error\\DebugFlag;\n\n$executionResult = GraphQL::executeQuery(/*args*/);\n\n// Will throw if there was an exception in resolver during execution\n$executionResult -&gt;toArray(DebugFlag::INCLUDE_DEBUG_MESSAGE | DebugFlag::RETHROW_INTERNAL_EXCEPTIONS);\n</code></pre> <p>If you only want to re-throw Exceptions that are not marked as safe through the <code>ClientAware</code> interface, use <code>DebugFlag::RETHROW_UNSAFE_EXCEPTIONS</code>.</p>"},{"location":"error-handling/#custom-error-handling-and-formatting","title":"Custom Error Handling and Formatting","text":"<p>It is possible to define custom formatter and handler for result errors.</p> <p>Formatter is responsible for converting instances of <code>GraphQL\\Error\\Error</code> to an array. Handler is useful for error filtering and logging.</p> <p>For example, these are default formatter and handler:</p> <pre><code>use GraphQL\\GraphQL;\nuse GraphQL\\Error\\Error;\nuse GraphQL\\Error\\FormattedError;\n\n$result = GraphQL::executeQuery(/* $args */)\n    -&gt;setErrorFormatter(fn (Error $error): array =&gt; FormattedError::createFromException($error))\n    -&gt;setErrorsHandler(fn (array $errors, callable $formatter): array =&gt; array_map($formatter, $errors))\n    -&gt;toArray();\n</code></pre> <p>Note that when you pass debug flags to toArray() your custom formatter will still be decorated with same debugging information mentioned above.</p>"},{"location":"error-handling/#schema-errors","title":"Schema Errors","text":"<p>So far we only covered errors which occur during query execution process. Schema definition can also throw <code>GraphQL\\Error\\InvariantViolation</code> if there is an error in one of type definitions.</p> <p>Usually such errors mean that there is some logical error in your schema. In this case it makes sense to return a status code <code>500 (Internal Server Error)</code> for GraphQL endpoint:</p> <pre><code>use GraphQL\\GraphQL;\nuse GraphQL\\Type\\Schema;\nuse GraphQL\\Error\\FormattedError;\n\ntry {\n    $schema = new Schema([\n        // ...\n    ]);\n\n    $body = GraphQL::executeQuery($schema, $query);\n    $status = 200;\n} catch(\\Exception $e) {\n    $body = [\n        'errors' =&gt; [FormattedError::createFromException($e)]\n    ];\n    $status = 500;\n}\n\nheader('Content-Type: application/json', true, $status);\necho json_encode($body, JSON_THROW_ON_ERROR);\n</code></pre>"},{"location":"executing-queries/","title":"Executing Queries","text":""},{"location":"executing-queries/#using-facade-method","title":"Using Facade Method","text":"<p>Query execution is a complex process involving multiple steps, including query parsing, validating and finally executing against your schema.</p> <p>graphql-php provides a convenient facade for this process in class <code>GraphQL\\GraphQL</code>:</p> <pre><code>use GraphQL\\GraphQL;\n\n$result = GraphQL::executeQuery(\n    $schema,\n    $queryString,\n    $rootValue = null,\n    $context = null,\n    $variableValues = null,\n    $operationName = null,\n    $fieldResolver = null,\n    $validationRules = null\n);\n</code></pre> <p>It returns an instance of <code>GraphQL\\Executor\\ExecutionResult</code> which can be easily converted to array:</p> <pre><code>$serializableResult = $result-&gt;toArray();\n</code></pre> <p>Returned array contains data and errors keys, as described by the GraphQL spec. This array is suitable for further serialization (e.g. using json_encode). See also the section on error handling and formatting.</p>"},{"location":"executing-queries/#method-arguments","title":"Method arguments","text":"<p>Description of executeQuery method arguments:</p> Argument Type Notes schema <code>GraphQL\\Type\\Schema</code> Required. Instance of your application Schema queryString <code>string</code> or <code>GraphQL\\Language\\AST\\DocumentNode</code> Required. Actual GraphQL query string to be parsed, validated and executed. If you parse query elsewhere before executing - pass corresponding AST document here to avoid new parsing. rootValue <code>mixed</code> Any value that represents a root of your data graph. It is passed as the 1st argument to field resolvers of Query type. Can be omitted or set to null if actual root values are fetched by Query type itself. context <code>mixed</code> Any value that holds information shared between all field resolvers. Most often they use it to pass currently logged in user, locale details, etc.It will be available as the 3rd argument in all field resolvers. (see section on Field Definitions for reference) graphql-php never modifies this value and passes it as is to all underlying resolvers. variableValues <code>array</code> Map of variable values passed along with query string. See section on query variables on official GraphQL website. Note that while variableValues must be an associative array, the values inside it can be nested using \\stdClass if desired. operationName <code>string</code> Allows the caller to specify which operation in queryString will be run, in cases where queryString contains multiple top-level operations. fieldResolver <code>callable</code> A resolver function to use when one is not provided by the schema. If not provided, the default field resolver is used. validationRules <code>array</code> A set of rules for query validation step. The default value is all available rules. Empty array would allow skipping query validation (may be convenient for persisted queries which are validated before persisting and assumed valid during execution)"},{"location":"executing-queries/#using-server","title":"Using Server","text":"<p>If you are building HTTP GraphQL API, you may prefer our Standard Server (compatible with express-graphql). It supports more features out of the box, including parsing HTTP requests, producing a spec-compliant response; batched queries; persisted queries.</p> <p>Usage example (with plain PHP):</p> <pre><code>use GraphQL\\Server\\StandardServer;\n\n$server = new StandardServer([/* server options, see below */]);\n$server-&gt;handleRequest(); // parses PHP globals and emits response\n</code></pre> <p>Server also supports PSR-7 request/response interfaces:</p> <pre><code>use GraphQL\\Server\\StandardServer;\nuse GraphQL\\Executor\\ExecutionResult;\nuse Psr\\Http\\Message\\RequestInterface;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\StreamInterface;\n\n/** @var RequestInterface $psrRequest */\n/** @var ResponseInterface $psrResponse */\n/** @var StreamInterface $psrBodyStream */\n$server = new StandardServer([/* server options, see below */]);\n$psrResponse = $server-&gt;processPsrRequest($psrRequest, $psrResponse, $psrBodyStream);\n\n\n// Alternatively create PSR-7 response yourself:\n\n/** @var ExecutionResult|ExecutionResult[] $result */\n$result = $server-&gt;executePsrRequest($psrRequest);\n$jsonResult = json_encode($result, JSON_THROW_ON_ERROR);\n$psrResponse = new SomePsr7ResponseImplementation($jsonResult );\n</code></pre> <p>PSR-7 is useful when you want to integrate the server into existing framework:</p> <ul> <li>PSR-7 for Laravel</li> <li>Symfony PSR-7 Bridge</li> <li>Slim</li> <li>Laminas Mezzio</li> </ul>"},{"location":"executing-queries/#server-configuration-options","title":"Server configuration options","text":"Argument Type Notes schema <code>Schema</code> Required. Instance of your application Schema rootValue <code>mixed</code> Any value that represents a root of your data graph. It is passed as the 1st argument to field resolvers of Query type. Can be omitted or set to null if actual root values are fetched by Query type itself. context <code>mixed</code> Any value that holds information shared between all field resolvers. Most often they use it to pass currently logged in user, locale details, etc.It will be available as the 3rd argument in all field resolvers. (see section on Field Definitions for reference) graphql-php never modifies this value and passes it as is to all underlying resolvers. fieldResolver <code>callable</code> A resolver function to use when one is not provided by the schema. If not provided, the default field resolver is used. validationRules <code>array</code> or <code>callable</code> A set of rules for query validation step. The default value is all available rules. The empty array would allow skipping query validation (may be convenient for persisted queries which are validated before persisting and assumed valid during execution).Pass <code>callable</code> to return different validation rules for different queries (e.g. empty array for persisted query and a full list of rules for regular queries). When passed, it is expected to have the following signature:  function (OperationParams $params, DocumentNode $node, $operationType): array queryBatching <code>bool</code> Flag indicating whether this server supports query batching (apollo-style). Defaults to false debugFlag <code>int</code> Debug flags. See docs on error debugging (flag values are the same). persistedQueryLoader <code>callable</code> A function which is called to fetch actual query when server encounters a queryId. The server does not implement persistence part (which you will have to build on your own), but it allows you to execute queries which were persisted previously. Expected function signature: function ($queryId, OperationParams $params) Function is expected to return query string or parsed DocumentNode Read more about persisted queries. errorFormatter <code>callable</code> Custom error formatter. See error handling docs. errorsHandler <code>callable</code> Custom errors handler. See error handling docs. promiseAdapter <code>PromiseAdapter</code> Required for Async PHP only."},{"location":"executing-queries/#using-config-class","title":"Using config class","text":"<p>If you prefer fluid interface for config with autocomplete in IDE and static time validation, use <code>GraphQL\\Server\\ServerConfig</code> instead of an array:</p> <pre><code>use GraphQL\\Server\\ServerConfig;\nuse GraphQL\\Server\\StandardServer;\n\n$config = ServerConfig::create()\n    -&gt;setSchema($schema)\n    -&gt;setErrorFormatter($myFormatter)\n    -&gt;setDebugFlag($debug)\n;\n\n$server = new StandardServer($config);\n</code></pre>"},{"location":"executing-queries/#query-batching","title":"Query batching","text":"<p>Standard Server supports query batching (apollo-style).</p> <p>One of the major benefits of Server over a sequence of executeQuery() calls is that Deferred resolvers won't be isolated in queries. So for example following batch will require single DB request (if user field is deferred):</p> <pre><code>[\n{\n\"query\": \"{user(id: 1) { id }}\"\n},\n{\n\"query\": \"{user(id: 2) { id }}\"\n},\n{\n\"query\": \"{user(id: 3) { id }}\"\n}\n]\n</code></pre> <p>To enable query batching, pass queryBatching option in server config:</p> <pre><code>use GraphQL\\Server\\StandardServer;\n\n$server = new StandardServer([\n    'queryBatching' =&gt; true\n]);\n</code></pre>"},{"location":"executing-queries/#custom-validation-rules","title":"Custom Validation Rules","text":"<p>Before execution, a query is validated using a set of standard rules defined by the GraphQL spec. It is possible to override standard set of rules globally or per execution.</p> <p>Add rules globally:</p> <pre><code>use GraphQL\\Validator\\Rules;\nuse GraphQL\\Validator\\DocumentValidator;\n\n// Add to standard set of rules globally:\nDocumentValidator::addRule(new Rules\\DisableIntrospection());\n</code></pre> <p>Custom rules per execution:</p> <pre><code>use GraphQL\\GraphQL;\nuse GraphQL\\Validator\\Rules;\n\n$myValidationRules = array_merge(\n    GraphQL::getStandardValidationRules(),\n    [\n        new Rules\\QueryComplexity(100),\n        new Rules\\DisableIntrospection()\n    ]\n);\n\n$result = GraphQL::executeQuery(\n    $schema,\n    $queryString,\n    $rootValue = null,\n    $context = null,\n    $variableValues = null,\n    $operationName = null,\n    $fieldResolver = null,\n    $myValidationRules // &lt;-- this will override global validation rules for this request\n);\n</code></pre> <p>Or with a standard server:</p> <pre><code>use GraphQL\\Server\\StandardServer;\n\n$server = new StandardServer([\n    'validationRules' =&gt; $myValidationRules\n]);\n</code></pre>"},{"location":"getting-started/","title":"Getting Started","text":""},{"location":"getting-started/#prerequisites","title":"Prerequisites","text":"<p>This documentation assumes your familiarity with GraphQL concepts. If it is not the case - first learn about GraphQL on the official website.</p>"},{"location":"getting-started/#installation","title":"Installation","text":"<p>Using composer, run:</p> <pre><code>composer require webonyx/graphql-php\n</code></pre>"},{"location":"getting-started/#upgrading","title":"Upgrading","text":"<p>We try to keep library releases backwards compatible when possible. For breaking changes we provide upgrade instructions.</p>"},{"location":"getting-started/#install-tools-optional","title":"Install Tools (optional)","text":"<p>While it is possible to communicate with GraphQL API using regular HTTP tools it is way more convenient for humans to use GraphiQL - an in-browser IDE for exploring GraphQL APIs.</p> <p>It provides syntax-highlighting, auto-completion and auto-generated documentation for GraphQL API.</p> <p>The easiest way to use it is to install one of the existing Google Chrome extensions:</p> <ul> <li>ChromeiQL</li> <li>GraphiQL Feen</li> </ul> <p>Alternatively, you can follow instructions on the GraphiQL page and install it locally.</p>"},{"location":"getting-started/#hello-world","title":"Hello World","text":"<p>Let's create a type system that will be capable to process the following simple query:</p> <pre><code>query {\n  echo(message: \"Hello World\")\n}\n</code></pre> <p>We need an object type with the field <code>echo</code>:</p> <pre><code>use GraphQL\\Type\\Definition\\ObjectType;\nuse GraphQL\\Type\\Definition\\Type;\n\n$queryType = new ObjectType([\n    'name' =&gt; 'Query',\n    'fields' =&gt; [\n        'echo' =&gt; [\n            'type' =&gt; Type::string(),\n            'args' =&gt; [\n                'message' =&gt; Type::nonNull(Type::string()),\n            ],\n            'resolve' =&gt; fn ($rootValue, array $args): string =&gt; $rootValue['prefix'] . $args['message'],\n        ],\n    ],\n]);\n</code></pre> <p>(Note: type definition can be expressed in different styles)</p> <p>The interesting piece here is the resolve option of the field definition. It is responsible for returning a value of our field. Values of scalar fields will be directly included in the response while values of composite fields (objects, interfaces, unions) will be passed down to nested field resolvers (not in this example though).</p> <p>Now when our type is ready, let's create a GraphQL endpoint file for it graphql.php:</p> <pre><code>use GraphQL\\GraphQL;\nuse GraphQL\\Type\\Schema;\n\n$schema = new Schema([\n    'query' =&gt; $queryType\n]);\n\n$rawInput = file_get_contents('php://input');\n$input = json_decode($rawInput, true);\n$query = $input['query'];\n$variableValues = isset($input['variables']) ? $input['variables'] : null;\n\ntry {\n    $rootValue = ['prefix' =&gt; 'You said: '];\n    $result = GraphQL::executeQuery($schema, $query, $rootValue, null, $variableValues);\n    $output = $result-&gt;toArray();\n} catch (\\Exception $e) {\n    $output = [\n        'errors' =&gt; [\n            [\n                'message' =&gt; $e-&gt;getMessage()\n            ]\n        ]\n    ];\n}\nheader('Content-Type: application/json');\necho json_encode($output, JSON_THROW_ON_ERROR);\n</code></pre> <p>Our example is finished. Try it by running:</p> <pre><code>php -S localhost:8080 graphql.php\ncurl http://localhost:8080 -d '{\"query\": \"query { echo(message: \\\"Hello World\\\") }\" }'\n</code></pre> <p>Check out the full source code of this example which also includes simple mutation.</p> <p>Check out the blog example for something which is closer to real-world apps or read about the details of schema definition.</p>"},{"location":"getting-started/#next-steps","title":"Next Steps","text":"<p>Obviously hello world only scratches the surface of what is possible.</p> <p>To learn by example, check out the blog example which is quite close to real-world GraphQL hierarchies.</p> <p>For a deeper understanding of GraphQL in general, check out concepts.</p> <p>To delve right into the implementation, see schema definition.</p>"},{"location":"schema-definition-language/","title":"Schema Definition Language","text":"<p>The schema definition language is a convenient way to define your schema, especially with IDE autocompletion and syntax validation.</p> <p>You can define this separately from your PHP code. An example for a schema.graphql file might look like this:</p> <pre><code>type Query {\n  greetings(input: HelloInput!): String!\n}\n\ninput HelloInput {\n  firstName: String!\n  lastName: String\n}\n</code></pre> <p>To create an executable schema instance from this file, use <code>GraphQL\\Utils\\BuildSchema</code>:</p> <pre><code>use GraphQL\\Utils\\BuildSchema;\n\n$contents = file_get_contents('schema.graphql');\n$schema = BuildSchema::build($contents);\n</code></pre> <p>By default, such a schema is created without any resolvers. We have to rely on the default field resolver and the root value to execute queries against this schema.</p>"},{"location":"schema-definition-language/#defining-resolvers","title":"Defining resolvers","text":"<p>To enable Interfaces, Unions, and custom field resolvers, you can pass the second argument callable $typeConfigDecorator to BuildSchema::build().</p> <p>It accepts a callable that receives the default type config produced by the builder and is expected to add missing options like resolveType for interface types or resolveField for object types.</p> <pre><code>use GraphQL\\Utils\\BuildSchema;\nuse GraphQL\\Language\\AST\\TypeDefinitionNode;\n\n$typeConfigDecorator = function (array $typeConfig, TypeDefinitionNode $typeDefinitionNode): array {\n    $name = $typeConfig['name'];\n    // ... add missing options to $typeConfig based on type $name\n    return $typeConfig;\n};\n\n$contents = file_get_contents('schema.graphql');\n$schema = BuildSchema::build($contents, $typeConfigDecorator);\n</code></pre> <p>You can learn more about using <code>$typeConfigDecorator</code> in examples/05-type-config-decorator.</p>"},{"location":"schema-definition-language/#performance-considerations","title":"Performance considerations","text":"<p>Method BuildSchema::build() produces a lazy schema automatically, so it works efficiently even with huge schemas.</p> <p>However, parsing the schema definition file on each request is suboptimal. It is recommended to cache the intermediate parsed representation of the schema for the production environment:</p> <pre><code>use GraphQL\\Language\\Parser;\nuse GraphQL\\Validator\\DocumentValidator;\nuse GraphQL\\Utils\\BuildSchema;\nuse GraphQL\\Utils\\AST;\n\n$cacheFilename = 'cached_schema.php';\n\nif (!file_exists($cacheFilename)) {\n    $document = Parser::parse(file_get_contents('./schema.graphql'));\n    DocumentValidator::assertValidSDL($document);\n    file_put_contents($cacheFilename, \"&lt;?php\\nreturn \" . var_export(AST::toArray($document), true) . \";\\n\");\n} else {\n    $document = AST::fromArray(require $cacheFilename); // fromArray() is a lazy operation as well\n}\n\n$typeConfigDecorator = function () {};\n$schema = BuildSchema::build($document, $typeConfigDecorator, ['assumeValidSDL' =&gt; true]);\n</code></pre>"},{"location":"schema-definition/","title":"Schema Definition","text":"<p>The schema is a container of your type hierarchy, which accepts root types in a constructor and provides methods for receiving information about your types to internal GraphQL tools.</p> <p>In graphql-php, the schema is an instance of <code>GraphQL\\Type\\Schema</code>:</p> <pre><code>use GraphQL\\Type\\Schema;\n\n$schema = new Schema([\n    'query' =&gt; $queryType,\n    'mutation' =&gt; $mutationType,\n]);\n</code></pre> <p>See possible constructor options below.</p>"},{"location":"schema-definition/#query-and-mutation-types","title":"Query and Mutation types","text":"<p>The schema consists of two root types:</p> <ul> <li>Query type is a surface of your read API</li> <li>Mutation type (optional) exposes write API by declaring all possible mutations in your app.</li> </ul> <p>Query and Mutation types are regular object types containing root-level fields of your API:</p> <pre><code>use GraphQL\\Type\\Definition\\ObjectType;\nuse GraphQL\\Type\\Definition\\Type;\n\n$queryType = new ObjectType([\n    'name' =&gt; 'Query',\n    'fields' =&gt; [\n        'hello' =&gt; [\n            'type' =&gt; Type::string(),\n            'resolve' =&gt; fn () =&gt; 'Hello World!',\n        ],\n        'hero' =&gt; [\n            'type' =&gt; $characterInterface,\n            'args' =&gt; [\n                'episode' =&gt; [\n                    'type' =&gt; $episodeEnum,\n                ],\n            ],\n            'resolve' =&gt; fn ($rootValue, array $args): Hero =&gt; StarWarsData::getHero($args['episode'] ?? null),\n        ]\n    ]\n]);\n\n$mutationType = new ObjectType([\n    'name' =&gt; 'Mutation',\n    'fields' =&gt; [\n        'createReview' =&gt; [\n            'type' =&gt; $createReviewOutput,\n            'args' =&gt; [\n                'episode' =&gt; Type::nonNull($episodeEnum),\n                'review' =&gt; Type::nonNull($reviewInputObject),\n            ],\n            // TODO\n            'resolve' =&gt; fn ($rootValue, array $args): Review =&gt; StarWarsData::createReview($args['episode'], $args['review']),\n        ]\n    ]\n]);\n</code></pre> <p>Keep in mind that other than the special meaning of declaring a surface area of your API, those types are the same as any other object type, and their fields work exactly the same way.</p> <p>Mutation type is also just a regular object type. The difference is in semantics. Field names of Mutation type are usually verbs and they almost always have arguments - quite often with complex input values (see Mutations and Input Types for details).</p>"},{"location":"schema-definition/#configuration-options","title":"Configuration Options","text":"<p>The schema constructor expects an instance of <code>GraphQL\\Type\\SchemaConfig</code> or an array with the following options:</p> Option Type Notes query <code>ObjectType</code> or <code>callable(): ?ObjectType</code> or <code>null</code> Required. Object type (usually named <code>Query</code>) containing root-level fields of your read API mutation <code>ObjectType</code> or <code>callable(): ?ObjectType</code> or <code>null</code> Object type (usually named <code>Mutation</code>) containing root-level fields of your write API subscription <code>ObjectType</code> or <code>callable(): ?ObjectType</code> or <code>null</code> Reserved for future subscriptions implementation. Currently presented for compatibility with introspection query of graphql-js, used by various clients (like Relay or GraphiQL) directives <code>array&lt;Directive&gt;</code> A full list of directives supported by your schema. By default, contains built-in @skip and @include directives. If you pass your own directives and still want to use built-in directives - add them explicitly. For example: array_merge(GraphQL::getStandardDirectives(), [$myCustomDirective]); types <code>array&lt;ObjectType&gt;</code> List of object types which cannot be detected by graphql-php during static schema analysis.Most often this happens when the object type is never referenced in fields directly but is still a part of a schema because it implements an interface which resolves to this object type in its resolveType callable.  Note that you are not required to pass all of your types here - it is simply a workaround for a concrete use-case. typeLoader <code>callable(string $name): Type</code> Expected to return a type instance given the name. Must always return the same instance if called multiple times, see lazy loading. See section below on lazy type loading."},{"location":"schema-definition/#using-config-class","title":"Using config class","text":"<p>If you prefer a fluid interface for the config with auto-completion in IDE and static time validation, use <code>GraphQL\\Type\\SchemaConfig</code> instead of an array:</p> <pre><code>use GraphQL\\Type\\SchemaConfig;\nuse GraphQL\\Type\\Schema;\n\n$config = SchemaConfig::create()\n    -&gt;setQuery($myQueryType)\n    -&gt;setTypeLoader($myTypeLoader);\n\n$schema = new Schema($config);\n</code></pre>"},{"location":"schema-definition/#lazy-loading-of-types","title":"Lazy loading of types","text":"<p>If your schema makes use of a large number of complex or dynamically-generated types, they can become a performance concern. There are a few best practices that can lessen their impact:</p> <ol> <li> <p>Use a type registry.    This will put you in a position to implement your own caching and lookup strategies, and GraphQL won't need to preload a map of all known types to do its work.</p> </li> <li> <p>Define each custom type as a callable that returns a type, rather than an object instance.    Then, the work of instantiating them will only happen as they are needed by each query.</p> </li> <li> <p>Define all of your object fields as callbacks.    If you're already doing #2 then this isn't needed, but it's a quick and easy precaution.</p> </li> </ol> <p>It is recommended to centralize this kind of functionality in a type registry. A typical example might look like the following:</p> <pre><code>// StoryType.php\nuse GraphQL\\Type\\Definition\\ObjectType;\n\nfinal class StoryType extends ObjectType\n{\n    public function __construct()\n    {\n        parent::__construct([\n            'fields' =&gt; static fn (): array =&gt; [\n                'author' =&gt; [\n                    'type' =&gt; Types::author(),\n                    'resolve' =&gt; static fn (Story $story): ?Author =&gt; DataSource::findUser($story-&gt;authorId),\n                ],\n            ],\n        ]);\n    }\n}\n\n// AuthorType.php\nuse GraphQL\\Type\\Definition\\ObjectType;\n\nfinal class AuthorType extends ObjectType\n{\n    public function __construct()\n    {\n        parent::__construct([\n            'description' =&gt; 'Writer of books',\n            'fields' =&gt; static fn (): array =&gt; [\n                'firstName' =&gt; Types::string(),\n            ],\n        ]);\n    }\n}\n\n// Types.php\nuse GraphQL\\Type\\Definition\\Type;\nuse GraphQL\\Type\\Definition\\NamedType;\n\nfinal class Types\n{\n    /** @var array&lt;string, Type&amp;NamedType&gt; */\n    private static array $types = [];\n\n    /** @return Type&amp;NamedType */\n    public static function load(string $typeName): Type\n    {\n        if (isset(self::$types[$typeName])) {\n            return self::$types[$typeName];\n        }\n\n        // For every type, this class must define a method with the same name\n        // but the first letter is in lower case.\n        $methodName = match ($typeName) {\n            'ID' =&gt; 'id',\n            default =&gt; lcfirst($typeName),\n        };\n        if (! method_exists(self::class, $methodName)) {\n            throw new \\Exception(\"Unknown GraphQL type: {$typeName}.\");\n        }\n\n        $type = self::{$methodName}(); // @phpstan-ignore-line variable static method call\n        if (is_callable($type)) {\n            $type = $type();\n        }\n\n        return self::$types[$typeName] = $type;\n    }\n\n    /** @return Type&amp;NamedType */\n    private static function byClassName(string $className): Type\n    {\n        $classNameParts = explode('\\\\', $className);\n        $baseClassName = end($classNameParts);\n        // All type classes must use the suffix Type.\n        // This prevents name collisions between types and PHP keywords.\n        $typeName = preg_replace('~Type$~', '', $baseClassName);\n\n        // Type loading is very similar to PHP class loading, but keep in mind\n        // that the **typeLoader** must always return the same instance of a type.\n        // We can enforce that in our type registry by caching known types.\n        return self::$types[$typeName] ??= new $className;\n    }\n\n    /** @return \\Closure(): (Type&amp;NamedType) */\n    private static function lazyByClassName(string $className): \\Closure\n    {\n        return static fn () =&gt; self::byClassName($className);\n    }\n\n    public static function boolean(): ScalarType { return Type::boolean(); }\n    public static function float(): ScalarType { return Type::float(); }\n    public static function id(): ScalarType { return Type::id(); }\n    public static function int(): ScalarType { return Type::int(); }\n    public static function string(): ScalarType { return Type::string(); }\n    public static function author(): callable { return self::lazyByClassName(AuthorType::class); }\n    public static function story(): callable { return self::lazyByClassName(StoryType::class); }\n    ...\n}\n\n// api/index.php\nuse GraphQL\\Type\\Definition\\ObjectType;\n\n$schema = new Schema([\n    'query' =&gt; new ObjectType([\n        'name' =&gt; 'Query',\n        'fields' =&gt; static fn() =&gt; [\n            'story' =&gt; [\n                'args'=&gt;[\n                  'id' =&gt; Types::int(),\n                ],\n                'type' =&gt; Types::story(),\n                'description' =&gt; 'Returns my A',\n                'resolve' =&gt; static fn ($rootValue, array $args): ?Story =&gt; DataSource::findStory($args['id']),\n            ],\n        ],\n    ]),\n    'typeLoader' =&gt; Types::load(...),\n]);\n</code></pre> <p>A working demonstration of this kind of architecture can be found in the 01-blog sample.</p>"},{"location":"schema-definition/#schema-validation","title":"Schema Validation","text":"<p>By default, the schema is created with only shallow validation of type and field definitions (because validation requires a full schema scan and is very costly on bigger schemas).</p> <p>There is a special method assertValid() on the schema instance which throws <code>GraphQL\\Error\\InvariantViolation</code> exception when it encounters any error, like:</p> <ul> <li>Invalid types used for fields/arguments</li> <li>Missing interface implementations</li> <li>Invalid interface implementations</li> <li>Other schema errors...</li> </ul> <p>Schema validation is supposed to be used in CLI commands or during a build step of your app. Don't call it in web requests in production.</p> <p>Usage example:</p> <pre><code>try {\n    $schema = new GraphQL\\Type\\Schema([\n        'query' =&gt; $myQueryType\n    ]);\n    $schema-&gt;assertValid();\n} catch (GraphQL\\Error\\InvariantViolation $e) {\n    echo $e-&gt;getMessage();\n}\n</code></pre>"},{"location":"security/","title":"Security","text":""},{"location":"security/#protection-against-malicious-queries","title":"Protection Against Malicious Queries","text":"<p>GraphQL allows a large degree of dynamism and flexibility for clients to control what happens on the server during query execution. Malicious clients may abuse this by sending very deep and complex queries whose execution exhausts server resources.</p> <p>At a basic level, it is recommended to limit the resources a single HTTP request can use through PHP settings such as:</p> <ul> <li><code>max_execution_time</code></li> <li><code>memory_limit</code></li> <li><code>post_max_size</code></li> </ul> <p>In addition, graphql-php offers security mechanisms that are specific to GraphQL.</p>"},{"location":"security/#query-complexity-analysis","title":"Query Complexity Analysis","text":"<p>This is a port of Query Complexity Analysis in Sangria.</p> <p>Complexity analysis is a separate validation rule which calculates query complexity score before execution. Every field in the query gets a default score 1 (including ObjectType nodes). Total complexity of the query is the sum of all field scores. For example, the complexity of introspection query is 109.</p> <p>If this score exceeds a threshold, a query is not executed and an error is returned instead.</p> <p>Complexity analysis is disabled by default. You may enable it by setting a maximum query complexity:</p> <pre><code>use GraphQL\\GraphQL;\nuse GraphQL\\Validator\\Rules\\QueryComplexity;\nuse GraphQL\\Validator\\DocumentValidator;\n\n$rule = new QueryComplexity(100);\nDocumentValidator::addRule($rule);\n\nGraphQL::executeQuery(/*...*/);\n</code></pre> <p>This will set the rule globally. Alternatively, you can provide validation rules per execution.</p> <p>To customize field score add complexity function to field definition:</p> <pre><code>use GraphQL\\Type\\Definition\\Type;\nuse GraphQL\\Type\\Definition\\ObjectType;\n\n$type = new ObjectType([\n    'name' =&gt; 'MyType',\n    'fields' =&gt; [\n        'someList' =&gt; [\n            'type' =&gt; Type::listOf(Type::string()),\n            'args' =&gt; [\n                'limit' =&gt; [\n                    'type' =&gt; Type::int(),\n                    'defaultValue' =&gt; 10\n                ]\n            ],\n            'complexity' =&gt; fn (int $childrenComplexity, array $args): int =&gt; $childrenComplexity * $args['limit'],\n        ]\n    ]\n]);\n</code></pre>"},{"location":"security/#limiting-query-depth","title":"Limiting Query Depth","text":"<p>This is a port of Limiting Query Depth in Sangria.</p> <p>This is a simpler approach that limits the nesting depth a query can have. For example, the depth of the default introspection query is 7.</p> <p>This rule is disabled by default. You may enable it by setting a maximum query depth:</p> <pre><code>use GraphQL\\GraphQL;\nuse GraphQL\\Validator\\Rules\\QueryDepth;\nuse GraphQL\\Validator\\DocumentValidator;\n\n$rule = new QueryDepth(10);\nDocumentValidator::addRule($rule);\n\nGraphQL::executeQuery(/*...*/);\n</code></pre> <p>This will set the rule globally. Alternatively, you can provide validation rules per execution.</p>"},{"location":"security/#disabling-introspection","title":"Disabling Introspection","text":"<p>Introspection is a mechanism for fetching schema structure. It is used by tools like GraphiQL for auto-completion, query validation, etc.</p> <p>Introspection is enabled by default. It means that anybody can get a full description of your schema by sending a special query containing meta fields __type and __schema .</p> <p>If you are not planning to expose your API to the general public, it makes sense to disable this feature.</p> <p>GraphQL PHP provides you separate validation rule which prohibits queries that contain __type or __schema fields. To disable introspection, add following rule:</p> <pre><code>use GraphQL\\GraphQL;\nuse GraphQL\\Validator\\Rules\\DisableIntrospection;\nuse GraphQL\\Validator\\DocumentValidator;\n\n$rule = new DisableIntrospection(DisableIntrospection::ENABLED);\nDocumentValidator::addRule($rule);\n\nGraphQL::executeQuery(/*...*/);\n</code></pre> <p>This will set the rule globally. Alternatively, you can provide validation rules per execution.</p>"},{"location":"type-definitions/","title":"Type Definitions","text":"<p>graphql-php represents a type as a class instance from the <code>GraphQL\\Type\\Definition</code> namespace:</p> <ul> <li><code>ObjectType</code></li> <li><code>InterfaceType</code></li> <li><code>UnionType</code></li> <li><code>InputObjectType</code></li> <li><code>ScalarType</code></li> <li><code>EnumType</code></li> </ul>"},{"location":"type-definitions/#input-vs-output-types","title":"Input vs. Output Types","text":"<p>All types in GraphQL are of two categories: input and output.</p> <ul> <li> <p>Output types (or field types) are: Scalar, Enum, Object,   Interface, Union</p> </li> <li> <p>Input types (or argument types) are: Scalar, Enum, Inputs</p> </li> </ul> <p>Obviously, NonNull and List types belong to both categories depending on their inner type.</p>"},{"location":"type-definitions/#definition-styles","title":"Definition styles","text":"<p>Several styles of type definitions are supported depending on your preferences.</p>"},{"location":"type-definitions/#inline-definitions","title":"Inline definitions","text":"<pre><code>use GraphQL\\Type\\Definition\\ObjectType;\nuse GraphQL\\Type\\Definition\\Type;\n\n$myType = new ObjectType([\n    'name' =&gt; 'MyType',\n    'fields' =&gt; [\n        'id' =&gt; Type::id()\n    ]\n]);\n</code></pre>"},{"location":"type-definitions/#class-per-type","title":"Class per type","text":"<pre><code>use GraphQL\\Type\\Definition\\ObjectType;\nuse GraphQL\\Type\\Definition\\Type;\n\nclass MyType extends ObjectType\n{\n    public function __construct()\n    {\n        $config = [\n            // Note: 'name' is not needed in this form:\n            // it will be inferred from class name by omitting namespace and dropping \"Type\" suffix\n            'fields' =&gt; [\n                'id' =&gt; Type::id()\n            ]\n        ];\n        parent::__construct($config);\n    }\n}\n</code></pre>"},{"location":"type-definitions/#schema-definition-language","title":"Schema definition language","text":"<pre><code>schema {\n  query: Query\n  mutation: Mutation\n}\n\ntype Query {\n  greetings(input: HelloInput!): String!\n}\n\ninput HelloInput {\n  firstName: String!\n  lastName: String\n}\n</code></pre> <p>Read more about building an executable schema using schema definition language.</p>"},{"location":"type-definitions/directives/","title":"Directives","text":""},{"location":"type-definitions/directives/#built-in-directives","title":"Built-in directives","text":"<p>The directive is a way for a client to give GraphQL server additional context and hints on how to execute the query. The directive can be attached to a field or fragment and can affect the execution of the query in any way the server desires.</p> <p>GraphQL specification includes two built-in directives:</p> <ul> <li>@include(if: Boolean) Only include this field or fragment in the result if the argument is true</li> <li>@skip(if: Boolean) Skip this field or fragment if the argument is true</li> </ul> <p>For example:</p> <pre><code>query Hero($episode: Episode, $withFriends: Boolean!) {\n  hero(episode: $episode) {\n    name\n    friends @include(if: $withFriends) {\n      name\n    }\n  }\n}\n</code></pre> <p>Here if $withFriends variable is set to false - friends section will be ignored and excluded from the response. Important implementation detail: those fields will never be executed (not just removed from response after execution).</p>"},{"location":"type-definitions/directives/#custom-directives","title":"Custom directives","text":"<p>graphql-php supports custom directives even though their presence does not affect the execution of fields. You can use <code>GraphQL\\Type\\Definition\\ResolveInfo</code> in field resolvers to modify the output depending on those directives or perform statistics collection.</p> <p>Other use case is your own query validation rules relying on custom directives.</p> <p>In graphql-php custom directive is an instance of <code>GraphQL\\Type\\Definition\\Directive</code> (or one of its subclasses) which accepts an array of following options:</p> <pre><code>use GraphQL\\Language\\DirectiveLocation;\nuse GraphQL\\Type\\Definition\\Type;\nuse GraphQL\\Type\\Definition\\Directive;\n\n$trackDirective = new Directive([\n    'name' =&gt; 'track',\n    'description' =&gt; 'Instruction to record usage of the field by client',\n    'locations' =&gt; [\n        DirectiveLocation::FIELD,\n    ],\n    'args' =&gt; [\n        'details' =&gt; [\n            'type' =&gt; Type::string(),\n            'description' =&gt; 'String with additional details of field usage scenario',\n            'defaultValue' =&gt; ''\n        ]\n    ]\n]);\n</code></pre> <p>See possible directive locations in <code>GraphQL\\Language\\DirectiveLocation</code>.</p>"},{"location":"type-definitions/enums/","title":"Enum Type Definition","text":"<p>Enumeration types are a special kind of scalar that is restricted to a particular set of allowed values.</p>"},{"location":"type-definitions/enums/#writing-enum-types","title":"Writing Enum Types","text":"<p>In graphql-php enum type is an instance of <code>GraphQL\\Type\\Definition\\EnumType</code> which accepts configuration array in constructor:</p> <pre><code>use GraphQL\\Type\\Definition\\EnumType;\n\n$episodeEnum = new EnumType([\n    'name' =&gt; 'Episode',\n    'description' =&gt; 'One of the films in the Star Wars Trilogy',\n    'values' =&gt; [\n        'NEWHOPE' =&gt; [\n            'value' =&gt; 4,\n            'description' =&gt; 'Released in 1977.'\n        ],\n        'EMPIRE' =&gt; [\n            'value' =&gt; 5,\n            'description' =&gt; 'Released in 1980.'\n        ],\n        'JEDI' =&gt; [\n            'value' =&gt; 6,\n            'description' =&gt; 'Released in 1983.'\n        ],\n    ]\n]);\n</code></pre> <p>This example uses an inline style for Enum Type definition, but you can also use inheritance or schema definition language.</p>"},{"location":"type-definitions/enums/#configuration-options","title":"Configuration options","text":"<p>Enum Type constructor accepts an array with following options:</p> Option Type Notes name <code>string</code> Required. Name of the type. When not set - inferred from array key (read about shorthand field definition below) description <code>string</code> Plain-text description of the type for clients (e.g. used by GraphiQL for auto-generated documentation) values <code>array</code> List of enumerated items, see below for expected structure of each entry <p>Each entry of values array in turn accepts following options:</p> Option Type Notes name <code>string</code> Required. Name of the item. When not set - inferred from array key (read about shorthand field definition below) value <code>mixed</code> Internal representation of enum item in your application (could be any value, including complex objects or callbacks) description <code>string</code> Plain-text description of enum value for clients (e.g. used by GraphiQL for auto-generated documentation) deprecationReason <code>string</code> Text describing why this enum value is deprecated. When not empty - item will not be returned by introspection queries (unless forced)"},{"location":"type-definitions/enums/#construction-from-php-enum","title":"Construction from PHP enum","text":"<p>You can reuse your existing PHP enums in GraphQL. Leverage PHP attributes to add descriptions and deprecate values:</p> <pre><code>use GraphQL\\Type\\Definition\\Deprecated;\nuse GraphQL\\Type\\Definition\\Description;\n\n#[Description(description: 'Sweet and juicy.')]\nenum Fruit\n{\n    #[Description(description: 'Rich in potassium.')]\n    case BANANA;\n\n    #[Deprecated(reason: 'Too sour.')]\n    case CITRON;\n}\n</code></pre> <p>PhpDocs will be used as descriptions if present, but are overridden by the <code>Description</code> attribute.</p> <p>Wrap them with <code>GraphQL\\Type\\Definition\\PhpEnumType</code> to use them in a GraphQL schema:</p> <pre><code>use GraphQL\\Type\\Definition\\PhpEnumType;\n\n$fruitEnumType = new PhpEnumType(Fruit::class);\n</code></pre> <p>The following type will be deduced from <code>Fruit</code>:</p> <pre><code>\"\"\"\nSweet and juicy.\n\"\"\"\nenum Fruit {\n  \"\"\"\n  Rich in potassium.\n  \"\"\"\n  BANANA\n\n  CITRON @deprecated(reason: \"Too sour.\")\n}\n</code></pre> <p>Conversion rules:</p> <ul> <li>Client-given arguments will be converted to enum instances</li> <li>Returned output values are expected to be enum instances</li> </ul>"},{"location":"type-definitions/enums/#shorthand-definitions","title":"Shorthand definitions","text":"<p>If internal representation of enumerated item is the same as item name, then you can use following shorthand for definition:</p> <pre><code>use GraphQL\\Type\\Definition\\EnumType;\n\n$episodeEnum = new EnumType([\n    'name' =&gt; 'Episode',\n    'description' =&gt; 'One of the films in the Star Wars Trilogy',\n    'values' =&gt; ['NEWHOPE', 'EMPIRE', 'JEDI']\n]);\n</code></pre> <p>which is equivalent of:</p> <pre><code>use GraphQL\\Type\\Definition\\EnumType;\n\n$episodeEnum = new EnumType([\n    'name' =&gt; 'Episode',\n    'description' =&gt; 'One of the films in the Star Wars Trilogy',\n    'values' =&gt; [\n        'NEWHOPE' =&gt; ['value' =&gt; 'NEWHOPE'],\n        'EMPIRE' =&gt; ['value' =&gt; 'EMPIRE'],\n        'JEDI' =&gt; ['value' =&gt; 'JEDI']\n    ]\n]);\n</code></pre> <p>which is in turn equivalent of the full form:</p> <pre><code>use GraphQL\\Type\\Definition\\EnumType;\n\n$episodeEnum = new EnumType([\n    'name' =&gt; 'Episode',\n    'description' =&gt; 'One of the films in the Star Wars Trilogy',\n    'values' =&gt; [\n        ['name' =&gt; 'NEWHOPE', 'value' =&gt; 'NEWHOPE'],\n        ['name' =&gt; 'EMPIRE', 'value' =&gt; 'EMPIRE'],\n        ['name' =&gt; 'JEDI', 'value' =&gt; 'JEDI']\n    ]\n]);\n</code></pre>"},{"location":"type-definitions/enums/#field-resolution","title":"Field Resolution","text":"<p>When object field is of Enum Type, field resolver is expected to return an internal representation of corresponding Enum item (value in config). graphql-php will then serialize this value to name to include in response:</p> <pre><code>use GraphQL\\Type\\Definition\\EnumType;\nuse GraphQL\\Type\\Definition\\ObjectType;\n\n$episodeEnum = new EnumType([\n    'name' =&gt; 'Episode',\n    'description' =&gt; 'One of the films in the Star Wars Trilogy',\n    'values' =&gt; [\n        'NEWHOPE' =&gt; [\n            'value' =&gt; 4,\n            'description' =&gt; 'Released in 1977.'\n        ],\n        'EMPIRE' =&gt; [\n            'value' =&gt; 5,\n            'description' =&gt; 'Released in 1980.'\n        ],\n        'JEDI' =&gt; [\n            'value' =&gt; 6,\n            'description' =&gt; 'Released in 1983.'\n        ],\n    ]\n]);\n\n$heroType = new ObjectType([\n    'name' =&gt; 'Hero',\n    'fields' =&gt; [\n        'appearsIn' =&gt; [\n            'type' =&gt; $episodeEnum,\n             // Actual entry in response will be 'appearsIn' =&gt; 'EMPIRE'\n            'resolve' =&gt; fn (): int =&gt; 5,\n        ]\n    ]\n]);\n</code></pre> <p>The Reverse is true when the enum is used as input type (e.g. as field argument). GraphQL will treat enum input as name and convert it into value before passing to your app.</p> <p>For example, given object type definition:</p> <pre><code>use GraphQL\\Type\\Definition\\Type;\nuse GraphQL\\Type\\Definition\\ObjectType;\n\n$heroType = new ObjectType([\n    'name' =&gt; 'Hero',\n    'fields' =&gt; [\n        'appearsIn' =&gt; [\n            'type' =&gt; Type::boolean(),\n            'args' =&gt; [\n                'episode' =&gt; Type::nonNull($enumType)\n            ],\n            'resolve' =&gt; fn ($hero, array $args): bool =&gt; $args['episode'] === 5,\n        ]\n    ]\n]);\n</code></pre> <p>Then following query:</p> <pre><code>fragment on Hero {\n    appearsInNewHope: appearsIn(NEWHOPE)\n    appearsInEmpire: appearsIn(EMPIRE)\n}\n</code></pre> <p>will return:</p> <pre><code>[\n    'appearsInNewHope' =&gt; false,\n    'appearsInEmpire' =&gt; true\n]\n</code></pre>"},{"location":"type-definitions/inputs/","title":"Input Object Type Definition","text":"<p>The GraphQL specification defines the Input Object type for complex inputs. It is similar to the Object type, but its fields have no args or resolve options and their type must be input type.</p>"},{"location":"type-definitions/inputs/#writing-input-object-types","title":"Writing Input Object Types","text":"<p>In graphql-php, Input Object Type is an instance of <code>GraphQL\\Type\\Definition\\InputObjectType</code> (or one of its subclasses) which accepts configuration array in its constructor:</p> <pre><code>use GraphQL\\Type\\Definition\\Type;\nuse GraphQL\\Type\\Definition\\InputObjectType;\n\n$filters = new InputObjectType([\n    'name' =&gt; 'StoryFiltersInput',\n    'fields' =&gt; [\n        'author' =&gt; [\n            'type' =&gt; Type::id(),\n            'description' =&gt; 'Only show stories with this author id'\n        ],\n        'popular' =&gt; [\n            'type' =&gt; Type::boolean(),\n            'description' =&gt; 'Only show popular stories (liked by several people)'\n        ],\n        'tags' =&gt; [\n            'type' =&gt; Type::listOf(Type::string()),\n            'description' =&gt; 'Only show stories which contain all of those tags'\n        ]\n    ]\n]);\n</code></pre> <p>Every field may be of other InputObjectType (thus complex hierarchies of inputs are possible)</p>"},{"location":"type-definitions/inputs/#configuration-options","title":"Configuration options","text":"<p>The constructor of <code>InputObjectType</code> accepts an <code>array</code> with the following options:</p> Option Type Notes name <code>string</code> Required. Unique name of this object type within Schema description <code>string</code> Plain-text description of this type for clients (e.g. used by GraphiQL for auto-generated documentation) isOneOf <code>bool</code> Indicates that an Input Object is a OneOf Input Object (and thus requires exactly one of its fields be provided). parseValue <code>callable(array&lt;string, mixed&gt;): mixed</code> Converts incoming values from their array representation to something else (e.g. a value object) fields <code>iterable&lt;FieldConfig&gt;</code> or <code>callable(): iterable&lt;FieldConfig&gt;</code> Required. An iterable describing object fields or callable returning such an iterable (see below). <p>Every entry in <code>fields</code> is an array with following entries:</p> Option Type Notes name <code>string</code> Required. Name of the input field. When not set - inferred from fields array key type <code>Type</code> Required. Instance of one of Input Types (Scalar, Enum, InputObjectType + any combination of those with nonNull and listOf modifiers) defaultValue <code>scalar</code> Default value of this input field. Use the internal value if specifying a default for an enum type description <code>string</code> Plain-text description of this input field for clients (e.g. used by GraphiQL for auto-generated documentation) deprecationReason <code>string</code> Plain-test reason for why this input field is deprecated."},{"location":"type-definitions/inputs/#using-input-object-type","title":"Using Input Object Type","text":"<p>In the example above we defined our InputObjectType <code>StoryFiltersInput</code>. Now let's use it in one of field arguments:</p> <pre><code>use GraphQL\\Type\\Definition\\Type;\nuse GraphQL\\Type\\Definition\\ObjectType;\n\n$queryType = new ObjectType([\n    'name' =&gt; 'Query',\n    'fields' =&gt; [\n        'stories' =&gt; [\n            'type' =&gt; Type::listOf($storyType),\n            'args' =&gt; [\n                'filters' =&gt; [\n                    'type' =&gt; $filters,\n                    'defaultValue' =&gt; [\n                        'popular' =&gt; true,\n                    ],\n                ],\n            ],\n            'resolve' =&gt; fn ($rootValue, array $args): array =&gt; DataSource::filterStories($args['filters']),\n        ],\n    ],\n]);\n</code></pre> <p>You can define defaultValue for fields with complex inputs as an associative array.</p> <p>Then GraphQL query could include filters as a literal value:</p> <pre><code>{\n  stories(filters: {\n    author: \"1\"\n    popular: false\n  }) {\n    ...\n  }\n}\n</code></pre> <p>Or as a query variable:</p> <pre><code>query ($filters: StoryFiltersInput!) {\n  stories(filters: $filters) {\n    ...\n  }\n}\n</code></pre> <pre><code>{\n\"filters\": {\n\"author\": \"1\",\n\"popular\": false\n}\n}\n</code></pre> <p>graphql-php will validate the input against your InputObjectType definition and pass it to your resolver as <code>$args['filters']</code>.</p>"},{"location":"type-definitions/inputs/#converting-input-array-to-value-object","title":"Converting Input Array to Value Object","text":"<p>If you want more type safety you can choose to parse the input array into a value object.</p> <pre><code>use GraphQL\\Type\\Definition\\Type;\nuse GraphQL\\Type\\Definition\\InputObjectType;\n\nfinal readonly class StoryFiltersInput\n{\n    public function __construct(\n        public string $author,\n        public ?bool $popular,\n        /** @var array&lt;string&gt; */\n        public array $tags\n    ) {}\n}\n\n$filters = new InputObjectType([\n    'name' =&gt; 'StoryFiltersInput',\n    'fields' =&gt; [\n        'author' =&gt; [\n            'type' =&gt; Type::nonNull(Type::string()),\n        ],\n        'popular' =&gt; [\n            'type' =&gt; Type::boolean(),\n        ],\n        'tags' =&gt; [\n            'type' =&gt; Type::nonNull(Type::listOf(Type::string())),\n        ]\n    ],\n    'parseValue' =&gt; fn (array $values): StoryFiltersInput =&gt; new StoryFiltersInput(\n        author: $values['author'],\n        popular: $values['popular'] ?? null,\n        tags: $values['tags'],\n    ),\n]);\n</code></pre> <p>The value of <code>$args['filters']</code> will now be an instance of <code>StoryFiltersInput</code>.</p> <p>The incoming values are converted using a depth-first traversal. Thus, nested input values will be passed through their respective <code>parseValue</code> functions before the parent receives their value.</p>"},{"location":"type-definitions/inputs/#using-the-isoneof-configuration-option","title":"Using the <code>isOneOf</code> Configuration Option","text":"<p>The <code>isOneOf</code> configuration option allows you to declare an input object as a OneOf Input Object. This means that exactly one of its fields must be provided when the input is used. This is useful when an argument can accept several alternative values, but never more than one at the same time.</p> <p>Suppose you want to allow a query to filter stories either by author or by tag, but not both together. You can define an input object with <code>isOneOf: true</code>:</p> <pre><code>use GraphQL\\Type\\Definition\\Type;\nuse GraphQL\\Type\\Definition\\InputObjectType;\n\n$storySearch = new InputObjectType([\n    'name' =&gt; 'StorySearchInput',\n    'isOneOf' =&gt; true,\n    'fields' =&gt; [\n        'author' =&gt; [\n            'type' =&gt; Type::id(),\n            'description' =&gt; 'Find stories by a specific author',\n        ],\n        'tag' =&gt; [\n            'type' =&gt; Type::string(),\n            'description' =&gt; 'Find stories with a specific tag',\n        ],\n    ],\n]);\n</code></pre> <p>This input object can then be used as an argument in a query:</p> <pre><code>$searchType = new ObjectType([\n    'name' =&gt; 'Query',\n    'fields' =&gt; [\n        'searchStories' =&gt; [\n            'type' =&gt; Type::listOf($storyType),\n            'args' =&gt; [\n                'search' =&gt; [\n                    'type' =&gt; $storySearch,\n                ],\n            ],\n            'resolve' =&gt; fn ($rootValue, array $args): array =&gt; DataSource::searchStories($args['search']),\n        ],\n    ],\n]);\n</code></pre> <pre><code>{\n  searchStories(search: { author: \"1\" }) {\n    id\n    title\n  }\n}\n</code></pre> <p>If you try to provide both fields at once, validation will fail:</p> <pre><code>{\n  searchStories(search: { author: \"1\", tag: \"php\" }) {\n    id\n    title\n  }\n}\n</code></pre> <p>graphql-php ensures that with <code>isOneOf: true</code>, exactly one field is set. This helps make APIs clearer and less error-prone when alternative inputs are required.</p>"},{"location":"type-definitions/interfaces/","title":"Interface Type Definition","text":"<p>An Interface is an abstract type that includes a certain set of fields that a type must include to implement the interface.</p>"},{"location":"type-definitions/interfaces/#writing-interface-types","title":"Writing Interface Types","text":"<p>In graphql-php interface type is an instance of <code>GraphQL\\Type\\Definition\\InterfaceType</code> (or one of its subclasses) which accepts configuration array in a constructor:</p> <pre><code>use GraphQL\\Type\\Definition\\InterfaceType;\nuse GraphQL\\Type\\Definition\\ObjectType;\nuse GraphQL\\Type\\Definition\\Type;\n\n$character = new InterfaceType([\n    'name' =&gt; 'Character',\n    'description' =&gt; 'A character in the Star Wars Trilogy',\n    'fields' =&gt; [\n        'id' =&gt; [\n            'type' =&gt; Type::nonNull(Type::string()),\n            'description' =&gt; 'The id of the character.',\n        ],\n        'name' =&gt; [\n            'type' =&gt; Type::string(),\n            'description' =&gt; 'The name of the character.'\n        ]\n    ],\n    'resolveType' =&gt; function ($value): ObjectType {\n        switch ($value-&gt;type ?? null) {\n            case 'human': return MyTypes::human();\n            case 'droid': return MyTypes::droid();\n            default: throw new Exception(\"Unknown Character type: {$value-&gt;type ?? null}\");\n        }\n    }\n]);\n</code></pre> <p>This example uses inline style for Interface definition, but you can also use inheritance or schema definition language.</p>"},{"location":"type-definitions/interfaces/#configuration-options","title":"Configuration options","text":"<p>The constructor of InterfaceType accepts an array. Below is a full list of allowed options:</p> Option Type Notes name <code>string</code> Required. Unique name of this interface type within Schema fields <code>array</code> Required. List of fields required to be defined by interface implementors. Same as Fields for Object Type description <code>string</code> Plain-text description of this type for clients (e.g. used by GraphiQL for auto-generated documentation) resolveType <code>callback</code> function ($value, $context, ResolveInfo $info) Receives $value from resolver of the parent field and returns concrete interface implementor for this $value."},{"location":"type-definitions/interfaces/#implementing-interface","title":"Implementing interface","text":"<p>To implement the Interface simply add it to interfaces array of Object Type definition:</p> <pre><code>use GraphQL\\Type\\Definition\\Type;\nuse GraphQL\\Type\\Definition\\ObjectType;\n\n$humanType = new ObjectType([\n    'name' =&gt; 'Human',\n    'fields' =&gt; [\n        'id' =&gt; [\n            'type' =&gt; Type::nonNull(Type::string()),\n            'description' =&gt; 'The id of the character.',\n        ],\n        'name' =&gt; [\n            'type' =&gt; Type::string(),\n            'description' =&gt; 'The name of the character.'\n        ]\n    ],\n    'interfaces' =&gt; [\n        $character\n    ]\n]);\n</code></pre> <p>Note that Object Type must include all fields of interface with exact same types (including nonNull specification) and arguments.</p> <p>The only exception is when object's field type is more specific than the type of this field defined in interface (see Covariant return types for interface fields below)</p>"},{"location":"type-definitions/interfaces/#covariant-return-types-for-interface-fields","title":"Covariant return types for interface fields","text":"<p>Object types implementing interface may change the field type to more specific. Example:</p> <pre><code>interface A {\n  field1: A\n}\n\ntype B implements A {\n  field1: B\n}\n</code></pre>"},{"location":"type-definitions/interfaces/#sharing-interface-fields","title":"Sharing Interface fields","text":"<p>Since every Object Type implementing an Interface must have the same set of fields - it often makes sense to reuse field definitions of Interface in Object Types:</p> <pre><code>use GraphQL\\Type\\Definition\\Type;\nuse GraphQL\\Type\\Definition\\ObjectType;\n\n$humanType = new ObjectType([\n    'name' =&gt; 'Human',\n    'interfaces' =&gt; [\n        $character\n    ],\n    'fields' =&gt; [\n        $character-&gt;getField('id'),\n        $character-&gt;getField('name'),\n        [\n            'name' =&gt; 'height',\n            'type' =&gt; Type::float(),\n        ],\n    ]\n]);\n</code></pre> <p>In this case, field definitions are created only once (as a part of the Interface Type) and then reused by all interface implementors. It can save several microseconds and kilobytes and ensures that field definitions of Interface and implementors are always in sync. Yet it creates a problem with the resolution of such fields.</p> <p>There are two ways how shared fields could be resolved:</p> <ol> <li> <p>If the field resolution algorithm is the same for all Interface implementors,    you can add the resolve option to the field definition in the Interface itself.</p> </li> <li> <p>If field resolution varies for different implementations, you can specify the resolveField option    in the Object Type config and handle field resolutions there.    (Note: The resolve option in field definitions has precedence over the resolveField option in object type definitions.)</p> </li> </ol>"},{"location":"type-definitions/interfaces/#interface-role-in-data-fetching","title":"Interface role in data fetching","text":"<p>The only responsibility of interface in Data Fetching process is to return concrete Object Type for given $value in resolveType. Then resolution of fields is delegated to resolvers of this concrete Object Type.</p> <p>If a resolveType option is omitted, graphql-php will loop through all interface implementors and use their isTypeOf callback to pick the first suitable one. This is obviously less efficient than single resolveType call. So it is recommended to define resolveType whenever possible.</p>"},{"location":"type-definitions/interfaces/#prevent-invisible-types","title":"Prevent invisible types","text":"<p>When object types that implement an interface are not directly referenced by a field, they cannot be discovered during schema introspection. For example:</p> <pre><code>type Query {\n    animal: Animal\n}\n\ninterface Animal {...}\n\ntype Cat implements Animal {...}\ntype Dog implements Animal {...}\n</code></pre> <p>In this example, <code>Cat</code> and <code>Dog</code> would be considered invisible types. Querying the <code>animal</code> field would fail, since no possible implementing types for <code>Animal</code> can be found.</p> <p>There are two possible solutions:</p> <ol> <li>Add fields that reference the invisible types directly, e.g.:</li> </ol> <pre><code>type Query {\n  dog: Dog\n  cat: Cat\n}\n</code></pre> <ol> <li>Pass the invisible types during schema construction, e.g.:</li> </ol> <pre><code>new GraphQLSchema([\n    'query' =&gt; ...,\n    'types' =&gt; [$cat, $dog]\n]);\n</code></pre>"},{"location":"type-definitions/lists-and-nonnulls/","title":"Lists and Non-Nulls","text":""},{"location":"type-definitions/lists-and-nonnulls/#lists","title":"Lists","text":"<p>graphql-php provides built-in support for lists. In order to create list type - wrap existing type with <code>GraphQL\\Type\\Definition\\Type::listOf()</code> modifier:</p> <pre><code>use GraphQL\\Type\\Definition\\Type;\nuse GraphQL\\Type\\Definition\\ObjectType;\n\n$userType = new ObjectType([\n    'name' =&gt; 'User',\n    'fields' =&gt; [\n        'emails' =&gt; [\n            'type' =&gt; Type::listOf(Type::string()),\n            'resolve' =&gt; fn (): array =&gt; [\n                'jon@example.com',\n                'jonny@example.com'\n            ],\n        ]\n    ]\n]);\n</code></pre> <p>Resolvers for such fields are expected to return array or instance of PHP's built-in Traversable interface (null is allowed by default too).</p> <p>If returned value is not of one of these types - graphql-php will add an error to result and set the field value to null (only if the field is nullable, see below for non-null fields).</p>"},{"location":"type-definitions/lists-and-nonnulls/#non-nulls","title":"Non-Nulls","text":"<p>By default, every field or argument can have a null value. To indicate the value must be non-null use the <code>GraphQL\\Type\\Definition\\Type::nonNull()</code> modifier:</p> <pre><code>use GraphQL\\Type\\Definition\\Type;\nuse GraphQL\\Type\\Definition\\ObjectType;\n\n$humanType = new ObjectType([\n    'name' =&gt; 'User',\n    'fields' =&gt; [\n        'id' =&gt; [\n            'type' =&gt; Type::nonNull(Type::id()),\n            'resolve' =&gt; fn (): string =&gt; uniqid(),\n        ],\n        'emails' =&gt; [\n            'type' =&gt; Type::nonNull(Type::listOf(Type::string())),\n            'resolve' =&gt; fn (): array =&gt; [\n                'jon@example.com',\n                'jonny@example.com'\n            ],\n        ]\n    ]\n]);\n</code></pre> <p>If resolver of non-null field returns null, graphql-php will add an error to result and exclude the whole object from the output (an error will bubble to first nullable parent field which will be set to null).</p> <p>Read the section on Data Fetching for details.</p>"},{"location":"type-definitions/object-types/","title":"Object Type Definition","text":"<p>Object Type is the most frequently used primitive in a typical GraphQL application.</p> <p>Conceptually Object Type is a collection of Fields. Each field, in turn, has its own type which allows building complex hierarchies.</p>"},{"location":"type-definitions/object-types/#writing-object-types","title":"Writing Object Types","text":"<p>In graphql-php object type is an instance of <code>GraphQL\\Type\\Definition\\ObjectType</code> (or one of its subclasses) which accepts a configuration array in its constructor:</p> <pre><code>use GraphQL\\Type\\Definition\\ObjectType;\nuse GraphQL\\Type\\Definition\\Type;\nuse GraphQL\\Examples\\Blog\\Data\\DataSource;\nuse GraphQL\\Examples\\Blog\\Data\\Story;\n\n$userType = new ObjectType([\n    'name' =&gt; 'User',\n    'description' =&gt; 'Our blog visitor',\n    'fields' =&gt; [\n        'firstName' =&gt; [\n            'type' =&gt; Type::string(),\n            'description' =&gt; 'User first name'\n        ],\n        'email' =&gt; Type::string()\n    ]\n]);\n\n$blogStory = new ObjectType([\n    'name' =&gt; 'Story',\n    'fields' =&gt; [\n        'body' =&gt; Type::string(),\n        'author' =&gt; [\n            'type' =&gt; $userType,\n            'description' =&gt; 'Story author',\n            'resolve' =&gt; fn (Story $blogStory): ?User =&gt; DataSource::findUser($blogStory-&gt;authorId),\n        ],\n        'likes' =&gt; [\n            'type' =&gt; Type::listOf($userType),\n            'description' =&gt; 'List of users who liked the story',\n            'args' =&gt; [\n                'limit' =&gt; [\n                    'type' =&gt; Type::int(),\n                    'description' =&gt; 'Limit the number of recent likes returned',\n                    'defaultValue' =&gt; 10\n                ]\n            ],\n            'resolve' =&gt; fn (Story $blogStory, array $args): array =&gt; DataSource::findLikes($blogStory-&gt;id, $args['limit']),\n        ]\n    ]\n]);\n</code></pre> <p>This example uses inline style for Object Type definitions, but you can also use inheritance or schema definition language.</p>"},{"location":"type-definitions/object-types/#configuration-options","title":"Configuration options","text":"Option Type Notes name <code>string</code> Required. Unique name of this object type within Schema fields <code>array</code> or <code>callable</code> Required. An array describing object fields or callable returning such an array. See field configuration options section below for expected structure of each array entry. See also the section on Circular types for an explanation of when to use callable for this option. description <code>string</code> Plain-text description of this type for clients (e.g. used by GraphiQL for auto-generated documentation) interfaces <code>array</code> or <code>callable</code> List of interfaces implemented by this type or callable returning such a list. See Interface Types for details. See also the section on Circular types for an explanation of when to use callable for this option. isTypeOf <code>callable</code> function ($value, $context, ResolveInfo $info): bool Expected to return true if $value qualifies for this type (see section about Abstract Type Resolution for explanation). resolveField <code>callable</code> function ($value, array $args, $context, ResolveInfo $info): mixed Given the $value of this type, it is expected to return value for a field defined in $info-&gt;fieldName. A good place to define a type-specific strategy for field resolution. See Data Fetching for details. argsMapper <code>callable</code> function (array $args, FieldDefinition, FieldNode): mixed Called once, when Executor resolves arguments for given field. Could be used to validate args and/or to map them to DTO/Object. visible <code>bool</code> or <code>callable</code> Defaults to <code>true</code>. The given callable receives no arguments and is expected to return a <code>bool</code>, it is called once when the field may be accessed. The field is treated as if it were not defined at all when this is <code>false</code>."},{"location":"type-definitions/object-types/#field-configuration-options","title":"Field configuration options","text":"Option Type Notes name <code>string</code> Required. Name of the field. When not set - inferred from fields array key (read about shorthand field definition below) type <code>Type</code> Required. An instance of internal or custom type. Note: type must be represented by a single instance within one schema (see also lazy loading of types) args <code>array</code> An array describing any number of possible field arguments, each element being an array. See field argument configuration options. resolve <code>callable</code> function ($objectValue, array $args, $context, ResolveInfo $info): mixed Given the $objectValue of this type, it is expected to return actual value of the current field. See section on Data Fetching for details complexity <code>callable</code> function (int $childrenComplexity, array $args): int Used to restrict query complexity. The feature is disabled by default, read about Security to use it. description <code>string</code> Plain-text description of this field for clients (e.g. used by GraphiQL for auto-generated documentation) deprecationReason <code>string</code> Text describing why this field is deprecated. When not empty - field will not be returned by introspection queries (unless forced)"},{"location":"type-definitions/object-types/#field-argument-configuration-options","title":"Field argument configuration options","text":"Option Type Notes name <code>string</code> Required. Name of the argument. When not set - inferred from args array key type <code>Type</code> Required. Instance of one of Input Types (scalar, enum, InputObjectType + any combination of those with nonNull and listOf modifiers) description <code>string</code> Plain-text description of this argument for clients (e.g. used by GraphiQL for auto-generated documentation) defaultValue <code>scalar</code> Default value for this argument. Use the internal value if specifying a default for an enum type"},{"location":"type-definitions/object-types/#shorthand-field-definitions","title":"Shorthand field definitions","text":"<p>Fields can be also defined in shorthand notation (with only name and type options):</p> <pre><code>'fields' =&gt; [\n    'id' =&gt; Type::id(),\n    'fieldName' =&gt; $fieldType\n]\n</code></pre> <p>which is equivalent of:</p> <pre><code>'fields' =&gt; [\n    'id' =&gt; ['type' =&gt; Type::id()],\n    'fieldName' =&gt; ['type' =&gt; $fieldName]\n]\n</code></pre> <p>which is in turn equivalent of the full form:</p> <pre><code>'fields' =&gt; [\n    ['name' =&gt; 'id', 'type' =&gt; Type::id()],\n    ['name' =&gt; 'fieldName', 'type' =&gt; $fieldName]\n]\n</code></pre> <p>Same shorthand notation applies to field arguments as well.</p>"},{"location":"type-definitions/object-types/#recurring-and-circular-types","title":"Recurring and circular types","text":"<p>Almost all real-world applications contain recurring or circular types. Think user friends or nested comments for example.</p> <p>graphql-php allows such types, but you have to use <code>callable</code> in option fields (and/or interfaces).</p> <p>For example:</p> <pre><code>use GraphQL\\Type\\Definition\\Type;\nuse GraphQL\\Type\\Definition\\ObjectType;\n\n$userType = new ObjectType([\n    'name' =&gt; 'User',\n    'fields' =&gt; function () use (&amp;$userType): array {\n        return [\n            'email' =&gt; [\n                'type' =&gt; Type::string()\n            ],\n            'friends' =&gt; [\n                'type' =&gt; Type::listOf($userType)\n            ]\n        ];\n    },\n]);\n</code></pre> <p>Same example for inheritance style of type definitions using a type registry (see lazy loading of types):</p> <pre><code>use GraphQL\\Type\\Definition\\ListOfType;\nuse GraphQL\\Type\\Definition\\ScalarType;\nuse GraphQL\\Type\\Definition\\Type;\nuse GraphQL\\Type\\Definition\\ObjectType;\n\nclass UserType extends ObjectType\n{\n    public function __construct()\n    {\n        parent::__construct([\n            'fields' =&gt; [\n                'email' =&gt; fn (): ScalarType =&gt; MyTypes::string(),\n                'friends' =&gt; fn (): ListOfType =&gt; MyTypes::listOf(MyTypes::user())\n            ],\n        ]);\n    }\n}\n\nclass MyTypes\n{\n    private static UserType $user;\n\n    public static function user(): UserType\n    {\n        return self::$user ??= new UserType();\n    }\n\n    public static function string(): ScalarType\n    {\n        return Type::string();\n    }\n\n    public static function listOf($type): ListOfType\n    {\n        return Type::listOf($type);\n    }\n}\n</code></pre>"},{"location":"type-definitions/object-types/#field-resolution","title":"Field Resolution","text":"<p>Field resolution is the primary mechanism in graphql-php for returning actual data for your fields. It is implemented using a resolveField callable in type definitions, or a resolve callable in field definitions (the latter has precedence).</p> <p>Read the section on Data Fetching for a complete description of this process.</p>"},{"location":"type-definitions/object-types/#custom-metadata","title":"Custom Metadata","text":"<p>All types in graphql-php accept a configuration array. In some cases, you may be interested in passing your own metadata for type or field definition.</p> <p>graphql-php preserves the original configuration array in every type or field instance in a public property $config. You may use it for custom implementations that are not natively supported by this library.</p>"},{"location":"type-definitions/scalars/","title":"Scalar Type Definition","text":"<p>Scalar types represent primitive leaf values in a GraphQL type system. When object fields have to resolve to some concrete data, that's where the scalar types come in.</p>"},{"location":"type-definitions/scalars/#built-in-scalar-types","title":"Built-in Scalar Types","text":"<p>The GraphQL specification describes several built-in scalar types. In graphql-php they are exposed as static methods of the class <code>GraphQL\\Type\\Definition\\Type</code>:</p> <pre><code>use GraphQL\\Type\\Definition\\Type;\n\n// Built-in Scalar types:\nType::string();  // String type\nType::int();     // Int type\nType::float();   // Float type\nType::boolean(); // Boolean type\nType::id();      // ID type\n</code></pre> <p>Those methods return instances of a subclass of <code>GraphQL\\Type\\Definition\\ScalarType</code>. Use them directly in type definitions or wrapped in a type registry (see lazy loading of types).</p>"},{"location":"type-definitions/scalars/#writing-custom-scalar-types","title":"Writing Custom Scalar Types","text":"<p>In addition to built-in scalars, you can define your own scalar types with additional validation. Typical examples of such types are Email, Date, Url, etc.</p> <p>In order to implement your own type, you must understand how scalars are handled in GraphQL. GraphQL deals with scalars in the following cases:</p> <ol> <li> <p>Convert the internal representation of a value, returned by your app (e.g. stored in a database    or hardcoded in the source code), to a serialized representation included in the response.</p> </li> <li> <p>Convert an input value, passed by a client in variables along with a GraphQL query, to    its internal representation used in your application.</p> </li> <li> <p>Convert an input literal value, hardcoded in a GraphQL query (e.g. field argument value), to    its internal representation used in your application.</p> </li> </ol> <p>Those cases are covered by the methods <code>serialize</code>, <code>parseValue</code> and <code>parseLiteral</code> of the abstract class <code>ScalarType</code> respectively.</p> <p>Here is an example of a simple Email type:</p> <pre><code>use GraphQL\\Error\\Error;\nuse GraphQL\\Error\\InvariantViolation;\nuse GraphQL\\Language\\AST\\StringValueNode;\nuse GraphQL\\Type\\Definition\\ScalarType;\nuse GraphQL\\Utils\\Utils;\n\nclass EmailType extends ScalarType\n{\n    // Note: name can be omitted. In this case it will be inferred from class name\n    // (suffix \"Type\" will be dropped)\n    public string $name = 'Email';\n\n    public function serialize($value)\n    {\n        if (!filter_var($value, FILTER_VALIDATE_EMAIL)) {\n            throw new InvariantViolation(\"Could not serialize following value as email: \" . Utils::printSafe($value));\n        }\n\n        return $this-&gt;parseValue($value);\n    }\n\n    public function parseValue($value)\n    {\n        if (!filter_var($value, FILTER_VALIDATE_EMAIL)) {\n            throw new Error(\"Cannot represent following value as email: \" . Utils::printSafeJson($value));\n        }\n\n        return $value;\n    }\n\n    public function parseLiteral(Node $valueNode, ?array $variables = null)\n    {\n        // Throw GraphQL\\Error\\Error vs \\UnexpectedValueException to locate the error in the query\n        if (!$valueNode instanceof StringValueNode) {\n            throw new Error('Query error: Can only parse strings got: ' . $valueNode-&gt;kind, [$valueNode]);\n        }\n\n        if (!filter_var($valueNode-&gt;value, FILTER_VALIDATE_EMAIL)) {\n            throw new Error(\"Not a valid email\", [$valueNode]);\n        }\n\n        return $valueNode-&gt;value;\n    }\n}\n</code></pre> <p>Or with inline style:</p> <pre><code>use GraphQL\\Type\\Definition\\CustomScalarType;\n\n$emailType = new CustomScalarType([\n    'name' =&gt; 'Email',\n    'serialize' =&gt; static function ($value) {/* See function body above */},\n    'parseValue' =&gt; static function ($value) {/* See function body above */},\n    'parseLiteral' =&gt; static function (Node $valueNode, ?array $variables = null) {/* See function body above */},\n]);\n</code></pre> <p>Keep in mind the passed functions will be called statically, so a passed in <code>callable</code> such as <code>[Foo::class, 'bar']</code> should only reference static class methods.</p>"},{"location":"type-definitions/unions/","title":"Union Type Definition","text":"<p>A Union is an abstract type that simply enumerates other Object Types. The value of Union Type is actually a value of one of included Object Types.</p>"},{"location":"type-definitions/unions/#writing-union-types","title":"Writing Union Types","text":"<p>In graphql-php union type is an instance of <code>GraphQL\\Type\\Definition\\UnionType</code> (or one of its subclasses) which accepts configuration array in a constructor:</p> <pre><code>use GraphQL\\Type\\Definition\\ObjectType;\nuse GraphQL\\Type\\Definition\\UnionType;\n\n$searchResultType = new UnionType([\n    'name' =&gt; 'SearchResult',\n    'types' =&gt; [\n        MyTypes::story(),\n        MyTypes::user()\n    ],\n    'resolveType' =&gt; function ($value): ObjectType {\n        switch ($value-&gt;type ?? null) {\n            case 'story': return MyTypes::story();\n            case 'user': return MyTypes::user();\n            default: throw new Exception(\"Unexpected SearchResult type: {$value-&gt;type ?? null}\");\n        }\n    },\n]);\n</code></pre> <p>This example uses inline style for Union definition, but you can also use inheritance or schema definition language.</p>"},{"location":"type-definitions/unions/#configuration-options","title":"Configuration options","text":"<p>The constructor of UnionType accepts an array. Below is a full list of allowed options:</p> Option Type Notes name <code>string</code> Required. Unique name of this interface type within Schema types <code>array</code> Required. List of Object Types included in this Union. Note that you can't create a Union type out of Interfaces or other Unions. description <code>string</code> Plain-text description of this type for clients (e.g. used by GraphiQL for auto-generated documentation) resolveType <code>callback</code> function ($value, $context, ResolveInfo $info): ObjectType Receives $value from resolver of the parent field and returns concrete Object Type for this $value."}]}